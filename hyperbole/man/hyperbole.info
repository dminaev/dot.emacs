This is hyperbole.info, produced by makeinfo version 4.8 from
hyperbole.texi.

   This manual is for GNU Hyperbole (version 5.0, 15 May 2007).

   Copyright (C) 1991, 1992, 1993, 1994, 1995, 2004, 2005, 2006  Free
Software Foundation, Inc.

   All trademarks referenced herein are trademarks of their respective
holders.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being "A GNU Manual," and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     "GNU Free Documentation License."

     (a) The FSF's Back-Cover Text is: "You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development."


File: hyperbole.info,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

Preface
*******

This manual is for GNU Hyperbole (version 5.0, 15 May 2007).

   Copyright (C) 1991, 1992, 1993, 1994, 1995, 2004, 2005, 2006  Free
Software Foundation, Inc.

   All trademarks referenced herein are trademarks of their respective
holders.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being "A GNU Manual," and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     "GNU Free Documentation License."

     (a) The FSF's Back-Cover Text is: "You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development."

   Hyperbole was designed and written by Bob Weiner.  Motorola, Inc.
funded and donated this work for free redistribution as part of the
InfoDock integrated software engineering and productivity toolset.  For
information on how to obtain Hyperbole, *Note Obtaining::.

   This manual explains user operation and summarizes basic developer
facilities of Hyperbole.  This major release of Hyperbole concentrates
on providing convenient access to information and control over its
display.  The Hyperbole outliner emphasizes flexible views and structure
manipulation within bodies of information.

   Hyperbole (pronounced Hi-purr-boe-lee) is an open, efficient,
programmable information management and hypertext system.  It is
intended for everyday work on any UNIX platform supported by GNU Emacs.
It works well with the versions of Emacs that support multiple X or
NEXTSTEP windows: Emacs 19, XEmacs (formerly called Lucid Emacs) and
Epoch.  Hyperbole allows hypertext buttons to be embedded within
unstructured and structured files, mail messages and news articles.  It
offers intuitive mouse-based control of information display within
multiple windows.  It also provides point-and-click access to Info
manuals, ftp archives, Wide-Area Information Servers (WAIS), and the
World-Wide Web (WWW) hypertext system through encapsulations of software
that support these protocols.

Hyperbole consists of four parts:

*Info Management
     an interactive information management interface, including a
     powerful rolodex, which anyone can use.  It is easy to pick up and
     use since it introduces only a few new mechanisms and provides
     user-level facilities through a menu interface, which you control
     from the keyboard or the mouse;

*Hypertext Outliner
     an outliner with multi-level autonumbering and permanent ids
     attached to each outline node for use as hypertext link anchors,
     plus flexible view specifications that can be embedded within
     links or used interactively;

*Button Types
     a set of hyper-button types that provides core hypertext and other
     behaviors.  Users can make simple changes to button types and those
     familiar with Emacs Lisp can quickly prototype and deliver new
     types;

*Programming Library
     a set of programming library classes for system developers who
     want to integrate Hyperbole with another user interface or as a
     back-end to a distinct system.  (All of Hyperbole is written in
     Emacs Lisp for ease of modification.  Although Hyperbole was
     initially designed as a prototype, it has been engineered for
     real-world usage and is well structured.)

   Hyperbole may be used simply for browsing through documents
pre-configured with Hyperbole buttons, in which case, one can safely
ignore most of the information in this manual.  The `DEMO' file
included in the Hyperbole distribution demonstrates many of Hyperbole's
standard facilities.  It offers a much less technical introduction for
Hyperbole users by providing good examples of how buttons may be used
and an introduction to the outliner.

   So if this manual is too detailed for your taste, you can skip it
entirely and just jump right into the demonstration, normally by typing
{`C-h h d d'}, assuming Hyperbole has already been installed at your
site.  Otherwise, *Note Installation::, for Hyperbole installation and
configuration information.

   Many users, however, will want to do more than browse with Hyperbole,
e.g.  create their own buttons.  The standard Hyperbole button editing
user interface is GNU Emacs-based, so a basic familiarity with the Emacs
editing model is useful.  The material covered in the GNU Emacs
tutorial, normally bound to {`C-h t'} within Emacs, is more than
sufficient as background.  If some GNU Emacs terms are unfamiliar to
you, *Note Emacs Glossary: (emacs)Glossary.

   Before we delve into Hyperbole, a number of acknowledgments are in
order.  Peter Wegner has encouraged the growth in this work.  Morris
Moore has helped me pursue my own research visions and kept me striving
for excellence.  Doug Engelbart has shown me the bigger picture and
continues to be an inspiration.  His work provides a model from which I
am beginning to draw.  Kellie Clark and I jointly designed the Hyperbole
outliner while sharing a life together.  Chris Nuzum, as a user of
Hyperbole, has helped demonstrate its power since its inception; he
knows how to work with Hyperbole far better than I.

* Menu:

* Introduction::
* Installation::
* Buttons::
* Smart Keys::
* Menus::
* Entering Arguments::
* Outliner::
* Rolodex::
* Window Configurations::
* Developing with Hyperbole::
* Glossary::
* Smart Key Reference::
* Outliner Keys::
* Suggestion or Bug Reporting::
* Questions and Answers::
* Future Work::
* References::
* Key Binding Index::
* Code and File Index::
* Concept Index::

 --- The Detailed Node Listing ---

Introduction

* Hyperbole Overview::
* Mail Lists::
* Manual Overview::

Installation

* Obtaining::
* Building::
* Installing::
* Configuring::

Configuring

* Internal Viewers::
* External Viewers::
* Link Variable Substitution::
* Button Colors::

Buttons

* Explicit Buttons::
* Global Buttons::
* Implicit Buttons::
* Action Types::
* Button Type Precedence::
* Button Files::
* Utilizing Explicit Buttons::

Utilizing Explicit Buttons

* Creation::
* Renaming::
* Deletion::
* Modification::
* Location::
* Buttons in Mail::
* Buttons in News::

Creation

* By Dragging::                 Creation Via Action Key Drags
* By Menu::                     Creation Via Menus

Outliner

* Menu Commands::
* Creating Outlines::
* Autonumbering::
* Idstamps::
* Editing::
* Viewing::
* Links::
* Cell Attributes::
* Outliner History::

Editing

* Adding and Killing::
* Moving Around::
* Relocating and Copying::
* Filling::
* Transposing::
* Splitting and Appending::
* Inserting and Importing::

Viewing

* Hiding and Showing::
* View Specs::

Rolodex

* Rolo Concepts::
* Rolo Menu::
* Rolo Keys::
* Rolo Settings::

Developing with Hyperbole

* Hook Variables::
* Creating Types::
* Explicit Button Technicalities::
* Encapsulating Systems::
* Embedding Hyperbole::

Creating Types

* Action Type Creation::
* Implicit Button Types::

Explicit Button Technicalities

* Button Label Normalization::
* Operational and Storage Formats::
* Programmatic Button Creation::

Smart Key Reference

* Smart Mouse Keys::
* Smart Keyboard Keys::


File: hyperbole.info,  Node: Introduction,  Next: Installation,  Prev: Top,  Up: Top

1 Introduction
**************

This chapter describes what Hyperbole is, lists some of its potential
applications, explains how to subscribe to its mail lists, and then
summarizes the structure of the rest of the manual.

* Menu:

* Hyperbole Overview::
* Mail Lists::
* Manual Overview::


File: hyperbole.info,  Node: Hyperbole Overview,  Next: Mail Lists,  Prev: Introduction,  Up: Introduction

1.1 Hyperbole Overview
======================

A Hyperbole user works with _buttons_ embedded within textual
documents; he may create, modify, move or delete buttons.  Each button
performs a specific action, such as linking to a file or executing a
shell command.

   There are three categories of Hyperbole buttons:
"explicit buttons"
     created by Hyperbole, accessible from within a single document;

"global buttons"
     created by Hyperbole, accessible anywhere within a user's network
     of documents;

"implicit buttons"
     created and managed by other programs or embedded within the
     structure of a document, accessible from within a single document.
     Hyperbole recognizes implicit buttons by contextual patterns
     given in their type specifications (explained later).

   Explicit Hyperbole buttons may be embedded within any type of text
file.  Implicit buttons may be recognized anywhere within a text file,
depending on the implicit button types that are available.  All global
buttons are stored in a single location and activated by entering their
names, rather than by direct selection, the means used to activate
explicit and implicit buttons.

To summarize:

     Button Category   Active Within        Activation Means      Managed By
     ========================================================================
     Explicit          a single document    direct selection      Hyperbole
     Global            any document         specifying its name   Hyperbole
     Implicit          a matching context   direct selection      other tools
     ========================================================================

   Hyperbole buttons may be clicked upon with a mouse to activate them
or to describe their actions.  Thus, a user can always check how a
button will act before activating it.  Buttons may also be activated
from a keyboard.  (In fact, virtually all Hyperbole operations,
including menu usage, may be performed from any standard character
terminal interface, so one need not be anchored to a workstation all
day).  *Note Smart Keys::.

   Hyperbole does not enforce any particular hypertext or information
management model, but instead allows you to organize your information in
large or small chunks as you see fit.  The Hyperbole outliner organizes
information hierarchies which may also contain links to external
information sources.

Some of Hyperbole's most important features include:

   * Buttons may link to information or may execute procedures, such as
     starting or communicating with external programs;

   * One simply drags between a button source location and a link
     destination to create or to modify a link button.  The same result
     can be achieved from the keyboard.

   * Buttons may be embedded within electronic mail messages;

   * Outlines allow rapid browsing, editing and movement of chunks of
     information organized into trees (hierarchies);

   * Other hypertext and information retrieval systems may be
     encapsulated under a Hyperbole user interface (a number of samples
     are provided).

Typical Hyperbole applications include:

*personal information management*
     Overlapping link paths provide a variety of views into an
     information space.  A search facility locates buttons in context
     and permits quick selection.

*documentation and code browsing*
     Cross-references may be embedded within documentation.  One can
     add a point-and-click interface to existing documentation, link
     code with associated design documents, or jump to the definition
     of an identifier by selecting its name within code or
     documentation.

*brainstorming*
     The Hyperbole outliner, *Note Outliner::, is an effective tool for
     capturing ideas and then quickly reorganizing them in a meaningful
     way.  Links to related ideas are easy to create, eliminating the
     need to copy and paste information into a single place.

*help/training systems*
     Tutorials containing buttons can show students how things work
     while explaining the concepts, e.g. an introduction to local
     commands.  This technique can be much more effective than written
     documentation alone.

*archive managers*
     Programs that manage archives from incoming information streams
     may be supplemented by having them add topic-based buttons that
     link to the archive holdings.  Users can then search and create
     their own links to archive entries.


File: hyperbole.info,  Node: Mail Lists,  Next: Manual Overview,  Prev: Hyperbole Overview,  Up: Introduction

1.2 Mail Lists
==============

If you use Hyperbole, you should consider joining one of the two
Hyperbole interest mailing lists.  *Note Menus::, and the description
of the the Msg/ menu item, for a convenient means of joining and
mailing to these lists.

   There are two Hyperbole-related mail lists.  One for discussing
using hyperbole, _hyperbole-users_, and the other for reporting bugs,
_bug-hyperbole_.

   To subscribe to the mail lists use the links below with your web
browser (or if your using hyperbole just click on them)

http://lists.gnu.org/mailman/listinfo/hyperbole-users

http://lists.gnu.org/mailman/listinfo/bug-hyperbole

     *All* administration of the Hyperbole mailing lists should be
     dealth with one of these web addresses.  That includes addition,
     change, or deletion.

     Don't send administrative requests to the mail lists or people will
     wonder why you don't know that the list administration is handled on
     the web interfaces.

So there are two Hyperbole-related mail lists:

<hyperbole-users@gnu.org>

     Mail list for discussion of all issues regarding using
     Hyperbole.

     Always use your Subject and/or Summary: lines to state the position that
     your message takes on the topic that it addresses.

     Statements end with periods, questions with question marks (typically),
     and high energy, high impact declarations with exclamation points.  This
     simple rule makes all e-mail communication much easier for recipients to
     handle appropriately.

     If you ask a question, your subject line should end with a ?,
     e.g. "Subject: How can man page SEE ALSOs be made implicit buttons?"  A
     "Subject: Re: How can ..." then indicates an answer to the question.
     Question messages should normally include your Hyperbole and Emacs
     version numbers and clearly explain your problem and surrounding issues.
     Otherwise, you will simply waste the time of those who may want to help
     you.  (Your top-level Hyperbole menu shows its version number and {`M-x
     emacs-version <RET>'} gives the other.)

     If you ask questions, you should consider adding to the discussion by
     telling people the kinds of work you are doing or contemplating doing
     with Hyperbole.  In this way, the list will not be overwhelmed by
     messages that ask for, but provide no information.

<bug-hyperbole@gnu.org>

     Bug reports and suggestions should go here. It is important here that
     you include as much info about your environment and program versions
     as possible.


File: hyperbole.info,  Node: Manual Overview,  Prev: Mail Lists,  Up: Introduction

1.3 Manual Overview
===================

Remember that the `DEMO' file included in the Hyperbole distribution
demonstrates many of Hyperbole's standard facilities, (*note Preface:
Top.) for more details.

   *Note Glossary::, for definitions of Hyperbole terms for quick
reference, so in some cases terms are not precisely defined within the
text.  Be sure to reference the glossary if a term is unclear to you.
Although you need not have a keen understanding of all of these terms, a
quick scan of the Glossary should help throughout Hyperbole use.

   If you have a question, feature suggestion or bug report on
Hyperbole, follow the instructions given in *Note Suggestion or Bug
Reporting::.  A few commonly asked questions are answered in the
manual, *Note Questions and Answers::.  If you are interested in
classic articles on hypertext, *Note References::.

   *Note Installation::, for explanations of how to obtain, install,
configure and load Hyperbole for use.

   *Note Buttons::, for an overview of Hyperbole buttons and how to use
them.

   *Note Smart Keys::, for an explanation of the innovative,
context-sensitive mouse and keyboard Action and Assist Keys offered by
Hyperbole.  *Note Smart Key Reference::, for a complete reference on
what the Action and Assist Keys do in each particular context that they
recognize.

   (Keep in mind as you read about how to use Hyperbole that in many
cases, it provides a number of overlapping interaction methods are
provided to support different work styles and hardware limitations.
You need learn only one with which you can become comfortable, in such
instances.)

   *Note Menus::, for summaries of Hyperbole menu commands and how to
use the minibuffer-based menus that work on dumb terminals.

   *Note Entering Arguments::, for special support that Hyperbole
provides for entering arguments when prompted for them.

   *Note Outliner::, for concept and usage information on the
autonumbered, hypertextual outliner.  A full summary of the outliner
commands that are bound to keys may be found in *Note Outliner Keys::.

   *Note Rolodex::, for concept and usage information on the rapid
lookup, hierarchical, free text record management system included with
Hyperbole.

   *Note Window Configurations::, for instructions on how to save and
restore the set of buffers and windows that appear with a frame.  This
feature lets you switch among working contexts easily, even on a dumb
terminal.  Such configurations only last throughout your current editor
session.

   Developers comfortable with Emacs Lisp will want to continue on
through to, *Note Developing with Hyperbole::.

   *Note Future Work::, for future directions in Hyperbole's evolution.


File: hyperbole.info,  Node: Installation,  Next: Buttons,  Prev: Introduction,  Up: Top

2 Installation
**************

Hyperbole must be installed at your site before you can use it.  The
following sections explain how to obtain, install and configure
Hyperbole for use.

   If you want to customize the basic Hyperbole initialization sequence
for yourself rather than the users at your site, you should make a
personal copy of the `hsite.el' file, modify it the way you want, and
then load it.  (If you are familiar with Emacs Lisp, *Note Hook
Variables::.)

* Menu:

* Obtaining::
* Building::
* Installing::
* Configuring::


File: hyperbole.info,  Node: Obtaining,  Next: Building,  Prev: Installation,  Up: Installation

2.1 Obtaining
=============

Hyperbole can be obtained via anonymous ftp on the Internet from:

   `ftp://ftp.gnu.org/gnu/hyperbole'.

Here are instructions for downloading and unpacking Hyperbole.

   Move to a directory below which you want the `hyperbole' directory to
be created.  Unpacking the Hyperbole archive will create the
`hyperbole' directory and will place all of the files below it.

       cd <LOCAL-EMACS-LISP-DIR>

Ftp to ftp.gnu.org.

        prompt> ftp ftp.gnu.org

Login as _anonymous_ with your own _<user-id>@<site-name>_ as a
password.

        Name (ftp.gnu.org): anonymous
        331 Guest login ok, send EMAIL address (e.g. user@host.domain)
            as password.
        Password:
        230 Guest login ok, access restrictions apply.

Move to the Hyperbole directory:

        ftp> cd gnu/hyperbole

Set your transfer mode to binary:

        ftp> bin
        200 Type set to I.

Turn off prompting:

        ftp> prompt
        Interactive mode off.

Retrieve just the Hyperbole archive and any diff-based patches (there
may not be any patches):

        ftp> mget hyperbole*
        ftp> mget hdiff*

Close the ftp connection:

        ftp> quit
        221 Goodbye.

Unpack the tar archive using the GNU version of the `zcat' program,
sometimes called `gzcat' or the `gunzip' program:

        zcat hyperbole*tar.gz | tar xvf -
     or
        gunzip hyperbole*tar.gz; tar xvf hyperbole*tar

Apply any patches you retrieved:

        cd hyperbole; patch < <patch-file>


File: hyperbole.info,  Node: Building,  Next: Installing,  Prev: Obtaining,  Up: Installation

2.2 Building
============

The following explains how to Use the Hyperbole `Makefile' to compile
any needed code, to generate the `hsite.el' file used for site-specific
Hyperbole customization, and to produce printable documentation.

   Edit the line near the top of `Makefile' that represents the emacs
version that you use, so that it corresponds to the emacs executable
name used on your system.  Then immediatly below there, set the EMACS
variable to the variable name for the emacs that you will use to
compile the Hyperbole Lisp files.

   You may also have to set the SITE-PRELOADS variable defined further
down in the file; follow the instructions that precede the
SITE-PRELOADS = line.  Make these changes now and save the `Makefile'.

   The following instructions use the term `<HYPERBOLE-DIR>/' to refer
to your `hyperbole/' directory, so substitute your own value.

To install Hyperbole for use with InfoDock, XEmacs, GNU Emacs or Epoch,
from a shell:

        cd <HYPERBOLE-DIR>; make

All of the .elc compiled Lisp files are already built for XEmacs and
V19, so this build will finish very quickly.  If you really want to
rebuild all of the .elc files, use:

        cd <HYPERBOLE-DIR>; make all-elc

To produce the Postscript version of the Hyperbole manual, you must have
the TeX formatter on your system:

        cd <HYPERBOLE-DIR>; make ps

To install Hyperbole for use with GNU Emacs V18 or Epoch:

        cd <HYPERBOLE-DIR>; make all-elc-v18

This will produce a complete set of Emacs V18 .elc files.


File: hyperbole.info,  Node: Installing,  Next: Configuring,  Prev: Building,  Up: Installation

2.3 Installing
==============

You may want to explore the Hyperbole configuration options before
installing it.  *Note Configuring::.  If you just want to get up and
running quickly, however, there is no need to configure anything, just
follow these instructions to install Hyperbole.

   Add the following lines to a site initialization file such as
`site-start.el' to set up so that all users have Hyperbole loaded for
them when they run Emacs.  Otherwise, each user will have to add these
lines to his own `~/.emacs' initialization file.

To autoload Hyperbole so that it loads only when needed:

     (defvar hyperb:dir "<HYPERBOLE-DIR>/")
       "Directory where the Hyperbole executable code is kept.
     It must end with a directory separator character.")

     (load (expand-file-name "hversion" hyperb:dir))
     (load (expand-file-name "hyperbole" hyperb:dir))

   This establishes a few key bindings and sets up Hyperbole to
automatically load whenever you activate its menu.  If you would rather
have the whole Hyperbole system loaded when you start up so that you can
always use the Smart Keys and other facilities, add the additional line:

     (require 'hsite)

   If you use mouse keys, be sure to add the above lines after any
setup of mouse key bindings, to ensure that Hyperbole's mouse keys are
properly initialized.  *Note Smart Keys::, for further details.  If you
use any Hyperbole mail or news support, *Note Buttons in Mail::, be
certain to perform all of your personal mail/news initializations
before the point at which you load Hyperbole.  Otherwise, the mail/news
support may not be configured properly.  For example, if you use the
Emacs add-on Supercite package, its setup should come before Hyperbole
initialization.

The Hyperbole Manual is included in the distribution in two forms:

     `man/hyperbole.info'   - online version
     `man/hyperbole.texi'   - source form

To add pointers to the Info version of the Hyperbole manual within your
Info directory, follow these instructions.  If INFO-DIRECTORY-LIST is
bound as a variable within your Emacs (all versions except V18 and
Epoch), then you can simply set it so that <HYPERBOLE-DIR> is an element
in the list:

     (setq Info-directory-list (cons "<HYPERBOLE-DIR>" Info-directory-list))

Otherwise, from a shell:

        cd to the directory given by your INFO-DIRECTORY variable
        rm hyperbole.info*; cp <HYPERBOLE-DIR>/man/hyperbole.info* .

For all versions of Emacs, add an Info menu entry for the Hyperbole
manual in your Info `dir' file (the `*' should be placed in the first
column of the file):

     * Hyperbole::  GNU Emacs-based everyday information management system.
         Use {C-h h d d} for a demonstration.  Includes context-sensitive
         mouse and keyboard support, a powerful rolodex, an autonumbered
         outliner with hyperlink anchors for each outline cell, and extensible
         hypertext facilities including hyper-links in mail and news messages.

   That's all there is to the installation.  Once Hyperbole has been
installed for use at your site, you can invoke it with {`C-h h'} or
{`M-x hyperbole <RET>'} to bring up the Hyperbole main menu in the
minibuffer window.


File: hyperbole.info,  Node: Configuring,  Prev: Installing,  Up: Installation

2.4 Configuring
===============

There are many Hyperbole configuration options that may be changed by
editing the `hyperbole.el' and `hsite.el' files in the `hyperbole/'
directory.  The following sections discuss the configuration options
most likely to be of interest to users.

* Menu:

* Internal Viewers::
* External Viewers::
* Link Variable Substitution::
* Button Colors::


File: hyperbole.info,  Node: Internal Viewers,  Next: External Viewers,  Prev: Configuring,  Up: Configuring

2.4.1 Internal Viewers
----------------------

When given a file name, Hyperbole will by default display the file for
editing within an Emacs buffer.  The HPATH:DISPLAY-ALIST variable can
be used to specify file name patterns, such as matching suffixes, which
will invoke a special Emacs Lisp function to display any matching files
within Emacs.  This can be used to format raw data files for convenient
display.

   Configure the HPATH:DISPLAY-ALIST variable in `hsite.el'.  Its value
is an association list whose elements are
(<file-name-regular-expression> . <function-of-one-arg>) pairs.  Any
path whose name matches a <file-name-regular-expression> will be
displayed by calling the associated <function-of-one-arg> with the file
name as the argument.

   *Note External Viewers::, for instructions on associating file names
with external, window-system specific viewers.


File: hyperbole.info,  Node: External Viewers,  Next: Link Variable Substitution,  Prev: Internal Viewers,  Up: Configuring

2.4.2 External Viewers
----------------------

If you will be using Hyperbole under a window system, you may want to
configure the HPATH:FIND-ALIST variable in `hsite.el' to support
hyperlinks which open files using non-Emacs tools, e.g. a fax reader or
a bitmap viewer.

   The value of HPATH:FIND-ALIST is determined when Hyperbole is
initialized based upon the current window system and the version of
Emacs in use.  The value is an association list whose elements are
(<file-name-regular-expression> . <viewer-program>) pairs.  Any path
whose name matches a <file-name-regular-expression> will be displayed
using the corresponding viewer-program.  If a <viewer-program> entry
contains a `%s' string, the filename to display will be substituted at
that point within the string.  Otherwise, the filename will be appended
to the <viewer-program> entry.  See the "x-suffixes" and
"nextstep-suffixes" settings within the definition of HPATH:FIND-ALIST
as examples.


File: hyperbole.info,  Node: Link Variable Substitution,  Next: Button Colors,  Prev: External Viewers,  Up: Configuring

2.4.3 Link Variable Substitution
--------------------------------

Another variable to consider modifying in the `hsite.el' file is
HPATH:VARIABLES.   This variable consists of a list of Emacs Lisp
variable names, each of which may have a pathname or a list of pathnames
as a value.  Whenever a Hyperbole file or directory link button is
created, its pathname is compared against the values in
HPATH:VARIABLES.  The first match found, if any, is selected and its
associated variable name is substituted into the link pathname, in
place of its literal value.  When the link is resolved (the button is
activated), Hyperbole replaces each variable with the first matching
value from this list.  (Environment variables are also replaced whenever
link paths are resolved.

   This permits sharing of links over wide areas, where the variable
values may differ between link creator and link activator.  The entire
process is wholly transparent to the user; it is explained here simply
to help you in deciding whether or not to modify the value of
HPATH:VARIABLES.


File: hyperbole.info,  Node: Button Colors,  Prev: Link Variable Substitution,  Up: Configuring

2.4.4 Configuring Button Colors
-------------------------------

When Hyperbole is run under a window system together with Emacs 19,
XEmacs or Epoch, it automatically highlights any explicit buttons in a
buffer and makes them flash when selected.  The main setting you may
want change is the selection of a color (or style) for button
highlighting and button flashing.  See the `hui-*-b*.el' files for
lists of potential colors and the code which supports this behavior.  A
call to `(hproperty:cycle-but-color)' within a Hyperbole initialization
sequence in the `hsite.el' file changes the color used to highlight and
flash explicit buttons.

   Additionally, under XEmacs and Emacs 19, if HPROPERTY:BUT-EMPHASIZE-P
is set to `t' in `hsite.el', then whenever the mouse pointer moves over
an explicit button, it will be emphasized in a different color or
style.  This emphasis is in addition to any non-mouse-sensitive button
highlighting.

   If you read in a file with explicit buttons before you load
Hyperbole, these buttons won't be highlighted.  Load Hyperbole and then
use `M-x hproperty:but-create <RET>' to highlight the buttons in the
current buffer.


File: hyperbole.info,  Node: Buttons,  Next: Smart Keys,  Prev: Installation,  Up: Top

3 Buttons
*********

This chapter explains the user-level notion of Hyperbole buttons.
Hyperbole buttons that are stored in files persist across Emacs
sessions, so they provide a convenient means of linking from one
information source to another.

* Menu:

* Explicit Buttons::
* Global Buttons::
* Implicit Buttons::
* Action Types::
* Button Type Precedence::
* Button Files::
* Utilizing Explicit Buttons::


File: hyperbole.info,  Node: Explicit Buttons,  Next: Global Buttons,  Prev: Buttons,  Up: Buttons

3.1 Explicit Buttons
====================

Hyperbole creates and manages _explicit buttons_ which look like this
`<(fake button)>' to a Hyperbole user.  They are quickly recognizable,
yet relatively non-distracting as one scans the text in which they are
embedded.  The text between the `<(' and `)>' delimiters is called the
"button label".  Spacing between words within a button label is
irrelevant to Hyperbole, so button labels may wrap across several lines
without causing a problem.

   Hyperbole stores the "button data" that gives an explicit button its
behavior, separately from the button label, in a file named `.hypb'
within the same directory as the file in which the button is created.
Thus, all files in the same directory share a common button data file.
Button data is comprised of individual "button attribute" values.  A
user never sees this data in its raw form but may see a formatted
version by asking for help on a button.

   Explicit buttons may be freely moved about within the buffer in which
they are created.  (No present support exists for moving buttons between
buffers).  A single button may also appear multiple times within the
same buffer; one simply copies the button label with its delimiters to
a new location in such cases.

   Each explicit button is assigned an action type which determines the
actions that it performs.  "Link action types" connect buttons to
particular types of referents.  "Activation" of such buttons then
displays the referents.

   Hyperbole does not manage referent data; this is left to the
applications that generate the data.  This means that Hyperbole
provides in-place linking and does not require reformatting of data to
integrate it with a Hyperbole framework.


File: hyperbole.info,  Node: Global Buttons,  Next: Implicit Buttons,  Prev: Explicit Buttons,  Up: Buttons

3.2 Global Buttons
==================

Access to explicit buttons depends upon the information on your screen
since they are embedded within particular buffers.  Sometimes it is
useful to activate buttons without regard to the information with which
you are presently working.  In such instances, you use "global
buttons", which are simply explicit buttons which may be activated or
otherwise operated upon by entering their labels when they are prompted
for, rather than selecting the buttons within a buffer.

   If you want a permanent link to a file section that you can follow at
any time, you can use a global button.  Or what about an Emacs keyboard
macro that you use frequently?  Create an `exec-kbd-macro' button with
an easy to type name and then you can easily activate it whenever the
need arises.


File: hyperbole.info,  Node: Implicit Buttons,  Next: Action Types,  Prev: Global Buttons,  Up: Buttons

3.3 Implicit Buttons
====================

Implicit buttons are those defined by the natural structure of a
document.  They are identified by contextual patterns which limit the
locations or states in which they can appear.  Their behavior is
determined by one or more actions which they trigger when activated.  An
action is derived from either a Hyperbole action type specification,
*Note Action Types::, or an Emacs Lisp function.  Implicit button types
may use the same action types that explicit buttons do.

   Implicit buttons never have any button data associated with them.
They are recognized in context based on predicate matches defined within
implicit button types.  For example, Hyperbole recognizes file names
enclosed in double quotes and can quickly display their associated files
in response to simple mouse clicks.

See `hibtypes.el' for complete examples.  Standard implicit button
types include (in alphabetical order):

`annot-bib'
     Displays annotated bibliography entries referenced internally,
     delimeters = [].  References must be delimited by square brackets,
     must begin with a word constituent character, and must not be in
     buffers whose names begin with a ' ' or '*' character.

`completion'
     Inserts completion at point into minibuffer or other window.

`dir-summary'
     Detects filename buttons in files named "MANIFEST" or "DIR".
     Displays selected files.  Each file name must be at the beginning
     of the line and must be followed by one or more spaces and then
     another non-space, non-parenthesis, non-brace character.

`doc-id'
     Displays an index entry for a site-specific document given its id.
     Ids must be delimited by 'doc-id-start' and 'doc-id-end' and must
     match the function given by 'doc-id-p'.  This permits creation of
     catalogued online libraries.  See `${hyperb:dir}/hib-doc-id.el'
     for more information.

`elisp-compiler-msg'
     Jumps to source code for definition associated with byte-compiler
     error message.  Works when activated anywhere within an error line.

`debugger-source'
     Jumps to source line associated with debugger stack frame or
     breakpoint lines.  This works with gdb, dbx, and xdb.  Such lines
     are recognized in any buffer.

`grep-msg'
     Jumps to line associated with grep or compilation error msgs.
     Messages are recognized in any buffer.

`hyp-address'
     Turns a Hyperbole e-mail list address into an implicit button which
     inserts Hyperbole environment information.  Useful when sending
     mail to a Hyperbole mail list.  See also the documentation for
     `actypes::hyp-config'.

`hyp-source'
     Turns source location entries in Hyperbole reports into buttons
     that jump to the associated location.

`Info-node'
     Makes "(file)node" buttons display the associated Info node.

`kbd-key'
     Executes a key sequence delimited by curly braces.  Key sequences
     should be in human readable form, e.g. {`C-b'}.  Forms such as
     {}, {}, and {^b} will not be recognized.

`klink'
     Follows a link delimited by <> to a koutline cell.  See
     documentation for `actypes::link-to-kotl' for valid link
     specifiers.

`mail-address'
     If on an e-mail address in a specific buffer type, mail to that
     address in another window. Applies to the rolodex match buffer,
     any buffer attached to a file in ROLO-FILE-LIST, or any buffer
     with `mail' or `rolo' (case-insensitive) within its name.

`man-apropos'

`UNIX manual'

`man pages'

`man apropos'
     Makes man apropos entries display associated man pages when
     selected.

`patch-msg'
     Jumps to source code associated with output from the `patch'
     program.  Patch applies diffs to source code.

`pathname'
     Makes a delimited, valid pathname display the path entry.  Also
     works for delimited and non-delimited ange-ftp and efs pathnames.
     See `hpath:at-p' function documentation for possible delimiters.
     See HPATH:SUFFIXES variable documentation for suffixes that are
     added to or removed from pathname when searching for a valid match.
     See `hpath:find' function documentation and HPATH:DISPLAY-ALIST
     and HPATH:FIND-ALIST variable documentation for special file
     display options.

`rfc'
     Retrieves and displays an Internet rfc referenced at point.
     Requires ange-ftp or efs when needed for remote retrievals.  The
     following formats are recognized: RFC822, rfc-822, and RFC 822.
     The HPATH:RFC variable specifies the location from which to
     retrieve RFCs."

`rfc-toc'
     Summarizes contents of an Internet rfc from anywhere within rfc
     buffer.  Each line in summary may be selected to jump to section.

`text-toc'
     Jumps to the text file section referenced by a table of contents
     entry at point. File name must contain `README' and there must be a
     `Table of Contents' or `Contents' label on a line by itself (it may
     begin with an asterisk), preceding the table of contents.  Each toc
     entry must begin with some whitespace followed by one or more
     asterisk characters.  Each file section name line must start with
     one or more asterisk characters at the very beginning of the line.

`www-url'
     When not in a w3 browser buffer, follow any non-ftp url (link) at
     point.  The variable, ACTION-KEY-URL-FUNCTION, can be used to
     customize the url browser that is used.

   The Hyperbole Smart Keys offer extensive additional context-sensitive
point-and-click type behavior beyond these standard implicit button
types.  *Note Smart Keys::.


File: hyperbole.info,  Node: Action Types,  Next: Button Type Precedence,  Prev: Implicit Buttons,  Up: Buttons

3.4 Action Types
================

"Action types" provide action procedures that specify button behavior.
The arguments needed by an action type are prompted for at button
creation time.  When a button is activated, the stored arguments are
fed to the action type's "action" body to achieve the desired result.
Hyperbole handles all of this transparently.

Standard action types in alphabetical order include:

`annot-bib'
     Follows internal ref KEY within an annotated bibliography,
     delimiters=[].

`completion'
     Inserts completion at point into minibuffer or other window.
     Unless at end of buffer or if completion has already been
     inserted, then deletes completions window.

`eval-elisp'
     Evaluates a Lisp expression LISP-EXPR.

`exec-kbd-macro'
     Executes KBD-MACRO REPEAT-COUNT times.  KBD-MACRO may be a string
     of editor command characters or a function symbol.  Optional
     REPEAT-COUNT nil means execute once, zero means repeat until error.

`exec-shell-cmd'
     Executes a SHELL-CMD string asynchronously.  Optional non-nil
     second argument INTERNAL-CMD means do not display the shell
     command line executed.  Optional non-nil third argument KILL-PREV
     means kill last output to shell buffer before executing SHELL-CMD.

`exec-window-cmd'
     Executes an external window-based SHELL-CMD string asynchronously.

`hyp-config'
     Inserts Hyperbole configuration info at end of optional OUT-BUF or
     current.

`hyp-request'
     Inserts Hyperbole mail list request help into optional OUT-BUF or
     current.

`hyp-source'
     Displays a buffer or file from a line beginning with
     'hbut:source-prefix'.

`kbd-key'
     Executes the function binding for KEY-SEQUENCE, delimited by {}.
     Returns t if a KEY-SEQUENCE has a binding, else nil.

`link-to-buffer-tmp'
     Displays a BUFFER in another window.  Link is generally only good
     for current Emacs session.  Use 'link-to-file' instead for a
     permanent link.

`link-to-directory'
     Displays a DIRECTORY in Dired mode in another window.

`link-to-doc'
     Displays online version of a document given by DOC-ID, in other
     window.  If the online version of a document is not found in
     DOC-ID-INDICES, an error is signalled.

`link-to-ebut'
     Performs action given by another button, specified by KEY and
     KEY-FILE.

`link-to-elisp-doc'
     Displays documentation for FUNC-SYMBOL.

`link-to-file'
     Displays a PATH in another window scrolled to optional POINT.
     With POINT, buffer is displayed with POINT at the top of the
     window.

`link-to-file-line'
     Displays a PATH in another window scrolled to LINE-NUM.

`link-to-kcell'
     Displays FILE with kcell given by CELL-REF at the top of the
     window.  CELL-REF may be a kcell's display label or its permanant
     idstamp.  If FILE is nil, the current buffer is used.  If CELL-REF
     is nil, the first cell in the view is shown.

`link-to-kotl'
     Displays at the top of another window the referent pointed to by
     LINK.  LINK may be of any of the following forms, with or without
     delimiters:
            < pathname [, cell-ref] >
            < [-!&] pathname >
            < @ cell-ref >

     See documentation for `kcell:ref-to-id' for valid cell-ref formats.

`link-to-Info-node'
     Displays an Info NODE in another window.  NODE must be a string of
     the form '(file)nodename'.

`link-to-mail'
     Displays mail msg with MAIL-MSG-ID from MAIL-FILE in other window.
     See documentation for the variable HMAIL:INIT-FUNCTION for
     information on how to specify a mail reader to use.

`link-to-regexp-match'
     Finds REGEXP's Nth occurrence in FILE and displays location at
     window top.  Returns t if found, signals an error if not.

`link-to-rfc'
     Retrieves and displays an Internet rfc given by RFC-NUM.  RFC-NUM
     may be a string or an integer.  Requires ange-ftp or efs for
     remote retrievals.

`link-to-string-match'
     Finds STRING's Nth occurrence in FILE and displays location at
     window top.  Returns t if found, nil if not.

`man-show'
     Displays man page on TOPIC, which may be of the form
     `<command>(<section>').

`rfc-toc'
     Computes and displays summary of an Internet rfc in BUF-NAME.
     Assumes point has already been moved to start of region to
     summarize.  Optional OPOINT is point to return to in BUF-NAME
     after displaying summary.

`text-toc'
     Jumps to the text file SECTION referenced by a table of contents
     entry at point.

`www-url'
     Follows a link given by URL.  The variable,
     ACTION-KEY-URL-FUNCTION, can be used to customize the url browser
     that is used.

   The use of action types provides a convenient way of specifying
button behavior without the need to know how to program.  Expert users
who are familiar with Emacs Lisp, however, may find that they often
want to tailor button actions in a variety of ways not easily captured
within a type system.  In such cases, HUI:EBUT-PROMPT-FOR-ACTION should
be set non-nil.  This will cause Hyperbole to prompt for an action to
override the button's action type at each explicit button creation.  For
those cases where the action type is sufficient, a nil value should be
entered for the action.  An action may be any Lisp form that may be
evaluated.


File: hyperbole.info,  Node: Button Type Precedence,  Next: Button Files,  Prev: Action Types,  Up: Buttons

3.5 Button Type Precedence
==========================

Explicit buttons always take precedence over implicit buttons.  Thus, if
a button selection is made which falls within both an explicit and
implicit button, only the explicit button will be selected.  Explicit
button labels are not allowed to overlap; Hyperbole's behavior in such
cases is undefined.

   If there is no explicit button at point during a selection request,
then each implicit button type predicate is tested in turn until one
returns non-nil or all are exhausted.  Since two implicit button types
may have overlapping domains (those contexts in which their predicates
are true), only the first matching type is used.  The type predicates
are tested in *reverse* order of definition, i.e. most recently entered
types are tested first, so that personal types defined after standard
system types take precedence.  It is important to keep this order in
mind when defining new implicit button types.  By making their match
predicates as specific as possible, one can minimize any overlapping of
implicit button type domains.

   Once a type name is defined, its precedence relative to other types
remains the same even if you redefine the body of the type, as long as
you don't change its name.  This allows incremental modifications to
types without having to worry about shifts in type precedence.  *Note
Creating Types::, for information on how to develop or modify types.


File: hyperbole.info,  Node: Button Files,  Next: Utilizing Explicit Buttons,  Prev: Button Type Precedence,  Up: Buttons

3.6 Button Files
================

It is often convenient to create lists of buttons that can be used as
menus to provide centralized access to distributed information pools or
for other purposes.  These files can serve as useful roadmaps to help
efficiently guide a user through both unfamiliar and highly familiar
information spaces.  Files that are created specifically for this
purpose, we call "button files".

   The Hyperbole menu system provides quick access to two types of these
button files: personal and directory-specific, through the ButFile menu.
(The variable, HBMAP:FILENAME, contains the base name of these standard
button files.  Its standard value is `HYPB'.)

   A personal button file may serve as a user's own roadmap to
frequently used resources.  Selection of the ButFile/PersonalFile menu
item displays this file for editing.  The default personal button file
is stored within the directory given by the HBMAP:DIR-USER variable
whose standard value is `~/.hyperb'.  The standard Hyperbole
configuration also appends all global buttons to the end of this file,
one per line, as they are created.  So you can edit or annotate them
within the file.

   A directory-specific button file may exist for each file system
directory.  Such files are useful for explaining the contents of
directories and pointing readers to particular highlights within the
directories.  Selection of the ButFile/DirFile menu item displays the
button file for the current directory; this provides an easy means of
updating this file when working on a file within the same directory.
If you want to view some other directory-specific button file, simply
use the normal Emacs file finding commands.

   One might suggest that menu quick access be provided for
group-specific and site-specific button files.  Instead, link buttons
to such things should be placed at the top of your personal button
file.  This provides a more flexible means of quick access.


File: hyperbole.info,  Node: Utilizing Explicit Buttons,  Prev: Button Files,  Up: Buttons

3.7 Utilizing Explicit Buttons
==============================

Explicit buttons are a fundamental building block for creating personal
or organizational hypertext networks with Hyperbole.  This section
summarizes the user-level operations available for managing these
buttons.

* Menu:

* Creation::
* Renaming::
* Deletion::
* Modification::
* Location::
* Buttons in Mail::
* Buttons in News::


File: hyperbole.info,  Node: Creation,  Next: Renaming,  Prev: Utilizing Explicit Buttons,  Up: Utilizing Explicit Buttons

3.7.1 Creation
--------------

* Menu:

* By Dragging::                 Creation Via Action Key Drags
* By Menu::                     Creation Via Menus


File: hyperbole.info,  Node: By Dragging,  Next: By Menu,  Prev: Creation,  Up: Creation

3.7.1.1 Creation Via Action Key Drags
.....................................

The most efficient way to create an explicit button interactively is to
use the mouse Action Key to drag from a button source window to a window
showing its link referent.  More specifically, you should split your
current Emacs frame into two windows: one which contains the point at
which you want a button to be inserted and another which shows the point
to which you want to link.  Depress the mouse Action Key at the point at
which the button should be inserted, drag to the other window and
release it at the point of the link referent.  The process becomes quite
simple with a little practice. (*Note Creation Via Menus: By Menu, for a
more detailed explanation of the explicit button creation process.)

   Hyperbole uses the link referent context to determine the type of
link to make.  If there are a few different types of links which are
applicable from the context, you will be prompted with a list of the
types.  Simply use the Action Key or the first letter of the link type
to select one of the type names and to finish the link creation.
Hyperbole will then insert explicit button delimiters around the button
label and will display a message in the minibuffer indicating both the
button name and its action/link type.

   If you run Emacs under a window system, you can emulate an Action Key
drag from the keyboard by: hitting {`M-o'}, the `hkey-operate' command,
at the button source location, moving to the link destination, e.g.
with {`C-x o'}, and then hitting {`M-o'} again.  This simulates a
depress and then release of the Action Key.  {`C-u M-o'} emulates drags
of the Assist Key.  This will not work when Hyperbole is run from a
dumb terminal Emacs session since drag actions are not supported
without a window system.


File: hyperbole.info,  Node: By Menu,  Prev: By Dragging,  Up: Creation

3.7.1.2 Creation Via Menus
..........................

You can alternatively use the Hyperbole menus to create explicit
buttons.  First, mark a short region of text in any fashion allowed by
GNU Emacs and then select the Hyperbole menu item sequence, Ebut/Create.
You will be prompted for the button's label with the marked region as
the default.  If you accept the default and enter the rest of the
information you are prompted for, the button will be created within the
current buffer and Hyperbole will surround the marked region with
explicit button delimiters to indicate success.

   If you do not mark a region before invoking the button create
command, you will be prompted for both a label and a target buffer for
the button and the delimited label text will be inserted into the
target buffer after a successful button creation.

   After Hyperbole has the button label and its target buffer, it will
prompt you for an action type for the button.  Use the {`?'} completion
help key to see the available types.  The type selected determines any
following values for which you will be prompted.

   If a previous button with the same label exists in the same buffer,
Hyperbole will add an "instance number" to the label when it adds the
delimiters so that the name is unique.  Thus, you don't have to worry
about accidental button name conflicts.  If you want the same button to
appear in multiple places within the buffer, just enter the label again
and delimit it yourself.  Hyperbole will interpret all occurrences of
the same delimited label within a buffer as the same button.

   If you create link buttons using the Hyperbole menus, the best
technique is to place on screen both the source buffer for the button
and the buffer to which it will link.  Mark the region of text to use
for your button label, invoke the button create command from the menu,
choose an action type which begins with `link-to-' and then use the
direct selection techniques mentioned in *Note Entering Arguments::, to
select the link referent.


File: hyperbole.info,  Node: Renaming,  Next: Deletion,  Prev: Creation,  Up: Utilizing Explicit Buttons

3.7.2 Renaming
--------------

Once an explicit button has been created, its label text must be
treated specially.  Any inter-word spacing within the label may be
freely changed, as may happen when a paragraph is refilled.  But a
special command must be invoked to rename it.

   The rename command operates in two different ways.  If point is
within a button label when it is invoked, it will tell you to edit the
button label and then invoke the rename command again.  The second
invocation will actually rename the button.  If instead the command is
originally invoked outside of any explicit button, it will prompt for
the button label to replace and the label to replace it with and then
will perform the rename.  All occurrences of the same button in the
buffer will be renamed, so you need locate only one occurrence of the
button.

   The rename command may be invoked from the Hyperbole menu via
Ebut/Rename.  A faster method is to use a key bound to the
`hui:ebut-rename' command.  Your site installation may include such a
key.  {`C-h w hui:ebut-rename <RET>'} should show you any key it is on.
If no key binding has been established or if you prefer one of your
own, simply bind it within your `~/.emacs' file.  We recommend the
{`C-c C-r'} key, as in: `(global-set-key "\C-c\C-r" 'hui:ebut-rename)'.


File: hyperbole.info,  Node: Deletion,  Next: Modification,  Prev: Renaming,  Up: Utilizing Explicit Buttons

3.7.3 Deletion
--------------

Ebut/Delete works similarly to the Rename command but deletes the
selected button.  The button's delimiters are removed to confirm the
delete.  If the delete command is invoked with a prefix argument, then
both the button label and the delimiters are removed as confirmation.

   Presently there is no way to recover a deleted button; it must be
recreated.  Therefore, the HUI:EBUT-DELETE-CONFIRM-P variable is true
by default, causing Hyperbole to require confirmation before
interactively deleting explicit buttons.  Set it to nil if you prefer no
confirmation.


File: hyperbole.info,  Node: Modification,  Next: Location,  Prev: Deletion,  Up: Utilizing Explicit Buttons

3.7.4 Modification
------------------

Ebut/Modify prompts you with each of the elements from the button's
data list and allows you to modify each in turn.

   There is a quicker way to modify explicit link buttons.  Simply drag
with the mouse Action Key from within the button label to a link
destination in a different window, just as you would when creating a
new button with a mouse drag.  Remember that drags may also be emulated
from the keyboard.  *Note Creation::.


File: hyperbole.info,  Node: Location,  Next: Buttons in Mail,  Prev: Modification,  Up: Utilizing Explicit Buttons

3.7.5 Location
--------------

The Ebut/Help menu can be used to summarize a single explicit button or
all such buttons within a single buffer.  The buttons summarized may
then be activated directly from the summary.

   Ebut/Help/BufferButs summarizes the explicit buttons in the order in
which they appear in the buffer.  Ebut/Help/CurrentBut summarizes only
the button at point.  Ebut/Help/OrderedButs summarizes the buttons in
alphabetical order.  All of these summary commands eliminate duplicate
instances of buttons from their help displays.

   Ebut/Search prompts for a search pattern and searches across all the
locations in which you have previously created explicit buttons.  It
asks you whether to match to any part of a button label or only complete
labels.  It then displays a list of button matches with a single line of
surrounding context from their sources.  Any button in the match list
may be activated as usual.  An Action Key press on the surrounding
context jumps to the associated source line or a press on the filename
preceding the matches jumps to the file without selecting a particular
line.

   There are presently no user-level facilities for globally locating
buttons created by others or for searching on particular button
attributes.


File: hyperbole.info,  Node: Buttons in Mail,  Next: Buttons in News,  Prev: Location,  Up: Utilizing Explicit Buttons

3.7.6 Buttons in Mail
---------------------

Hyperbole allows the embedding of buttons within electronic mail
messages that are composed in Emacs with the standard `(mail)' command,
normally bound to {`C-x m'} or with other Emacs-based mail composing
functions.  An enhanced mail reader can then be used to activate the
buttons within messages just like any other buttons.

   Hyperbole automatically supports the following mail readers:  Rmail,
*Note Rmail: (emacs)Rmail, VM, *Note Introduction: (vm)Introduction,
and PIEmail, and MH-e.  Button inclusion and activation within USENET
news articles is also supported in the same fashion via the GNUS news
reader, *Note Introduction: (gnus)Introduction, if available at your
site.  (The `hmail.el' file provides a generalized interface that can
be used to hook in other mail or news readers if the necessary
interface functions are written.)

   All explicit buttons to be mailed must be created within the outgoing
message buffer. There is no present support for including text from
other buffers or files which contain explicit buttons, except for the
ability to yank the contents of a message being replied to, together
with all of its buttons, via the `(mail-yank-original)' command bound
to {`C-c C-y'}.  From a user's perspective, buttons are created in
precisely the same way as in any other buffer.  They also appear just
like any other buttons to both the message sender and the reader who
uses the Hyperbole enhanced readers.  Button operation may be tested
any time before a message is sent.  A person who does not use Hyperbole
enhanced mail readers can still send messages with embedded buttons
since mail composing is independent of any mail reader choice.

   Hyperbole buttons embedded within received mail messages act just
like any other buttons.  The mail does not contain any of the action
type definitions used by the buttons, so the receiver must have these
or she will receive an error when she activates the buttons.  Buttons
which appear in message _Subject_ lines are copied to summary buffers
whenever such summaries are generated.  Thus, they may be activated from
either the message or summary buffers.

   Nothing bad will happen if a mail message with explicit buttons is
sent to a non-Hyperbole user.  The user will simply see the text of the
message followed by a series of lines of button data at its end.
Hyperbole mail users never see this data in its raw form.

   In order to alert readers of your mail messages that you can utilize
Hyperbole mail buttons, the system automatically inserts a comment into
each mail message that you compose to announce this fact.  The variable,
SMAIL:COMMENT controls this behavior.  See its documentation for
technical details.  By default, it produces a message of the form:

     Comments: Hyperbole mail buttons accepted, vX.XX.

where the X's indicate your Hyperbole version number.  You can cut this
out of particular messages before you send them.  If you don't want any
message at all, add the following to your `~/.emacs' file before the
point at which you load Hyperbole.

     (setq smail:comment nil)

   A final mail-related facility provided by Hyperbole is the ability to
save a pointer to a received mail message by creating an explicit button
with a `link-to-mail' action type.  When prompted for the mail message
to link to, if you press the Action Key on an Rmail message, the
appropriate parameter will be copied to the argument prompt, as
described in *Note Entering Arguments::.


File: hyperbole.info,  Node: Buttons in News,  Prev: Buttons in Mail,  Up: Utilizing Explicit Buttons

3.7.7 Buttons in News
---------------------

Explicit buttons may be embedded within outgoing USENET news articles
and may be activated from news articles that are being read.  This
support is available for the GNUS news reader.  It is enabled by default
within `hsite.el' by autoloading the `hgnus.el' file.

   All Hyperbole support should work just as it does when reading or
sending mail.  *Note Buttons in Mail::.  When reading news, buttons
which appear in message _Subject_ lines may be activated within the GNUS
subject buffer as well as the article buffer.  When posting news, the
*post-news* buffer is used for outgoing news articles rather than the
*mail* buffer.

   Remember that the articles you post do not contain the action type
definitions used by the buttons, so the receiver must have these or she
will receive an error when he activates the buttons.  You should also
keep in mind that most USENET readers will not be using Hyperbole, so if
they receive a news article containing explicit buttons, they will
wonder what the button data at the end of the message is.  You should
therefore limit distribution of such messages.  For example, if most
people at your site read news with GNUS and use Hyperbole, it would be
reasonable to embed buttons in postings to local newsgroups.

   In order to alert readers of your postings that you can utilize
Hyperbole mail buttons embedded within personal replies, the system
automatically inserts the same comment that is included within mail
messages to announce this fact.  *Note Buttons in Mail::, for details
and an explanation of how to turn this feature off.


File: hyperbole.info,  Node: Smart Keys,  Next: Menus,  Prev: Buttons,  Up: Top

4 Smart Keys
************

Hyperbole provides two special "Smart Keys" that perform
context-sensitive operations, the Action Key and the Assist Key.  By
default, the "Action Key" is bound to your shift-middle mouse button (or
shift-left on a 2-button mouse) and the "Assist Key" is bound to your
shift-right mouse button, assuming Hyperbole is run under an external
window system.  (InfoDock users should use the middle mouse button as
the Action Key, instead.)

   Mouse configuration is automatic for InfoDock, XEmacs, and Epoch
under the X window system and for GNU Emacs versions 18 and 19 under X,
OpenWindows, NEXTSTEP, SunView and Apollo's Display Manager, assuming
your Emacs program has been built with support for any of these window
systems.  The command, `hmouse-shift-buttons', can be used to select
between shifted and unshifted Smart Mouse Keys.

   By default (if HKEY-INIT is set to `t' in `hsite.el'), then
{`M-<RET>'} may also be used as the Action Key and {`C-u M-<RET>'} may
be used as the Assist Key.  In many read-only modes like Dired and
Rmail, {<RET>} also functions as the Action Key.  These key bindings
allow context sensitive operation from any keyboard.

   If you prefer other key bindings, simply bind the commands
`action-key' and `assist-key' to keyboard keys.  `hkey-either' may be
used instead if you prefer a single key binding for both commands; a
prefix argument then invokes `assist-key'.

   You may also bind `action-mouse-key' and `assist-mouse-key' to mouse
keys, as you like.

   The Action Key generally selects entities, creates links and
activates buttons.  The Assist Key generally provides help, such as
reporting on a button's attributes, or serves a complementary function
to whatever the Action Key does within a context.

   You can get a summary of what the Smart Keys do in all of their
different contexts by pressing the Assist Key in the right corner
(within the rightmost 3 characters) of a window modeline or by using
the Hyperbole Doc/SmartKy menu entry.

   The following table is an example of this summary.  Much of the
browsing power of Hyperbole comes from use of the Smart Keys, so you
should spend some time practicing how to use them.  This table may
appear daunting at first, but as you practice and notice that the Smart
Keys do just a few context-sensitive things per editor mode, you will
find it easy to just point and click and let Hyperbole do the rest.

   For extensive reference documentation on the Smart Keys, *Note Smart
Key Reference::.

==============================================================================
                                             Smart Keys
Context                         Action Key                 Assist Key
==============================================================================
Hyperbole
  On a menu item                Item is activated          Item help
  On an explicit button         Button is activated        Button help
  Reading argument
    1st press at an arg value   Value copied to minibuffer <- same
    2nd press at an arg value   Value used as argument     <- same
    In minibuffer               Minibuf arg is applied     Completion help
  On an implicit button         Button is activated        Button help
  Within an outline cell        Collapses and expands      Shows tree props
  Left of an outline cell       Creates a klink            Moves a tree
  Wrolo Match Buffer            Edits entries and mails to e-mail addresses

Mouse or Keyboard Display Control
  Line end, not end of buffer
    smart-scroll-proportional
      = t   (default)           Makes curr line top line   Bottom line
      = nil                     Scrolls up a windowful     Scrolls down
  End of Any Help buffer        Screen restored to previous state

Mouse-only Control
  Modeline down & wind release  Resize window height       <- same
  Drag from shared window side
    or from left of scroll bar  Resize window width        <- same
  Drag between windows          Create/modify a link but   Swap window buffers
  Horizontal drag within window
    Left to right               Scroll to buffer end       Split window across
    Right to left               Scroll to buffer begin     Delete window
  Vertical drag within window   Split window sideways      <- same
  Diagonal drag within window   Save ring screen-config    Restore ring config
  Click in modeline
    Left window edge            Bury buffer                Unbury bottom buf
    Right window edge           Info                       Smart Key summary
    Otherwise                   Action Key Hook            Assist Key Hook

Special Modes
  C/C++ Mode                    Jumps to id/include def    Jumps to next def
  Assembly Language Mode        Jumps to id/include def    Jumps to next def
  Any Lisp mode                 Jumps to id def            Jumps to next def
  Emacs Lisp Compiler Error     Jumps to def with error    <- same
  Grep or Occur match           Jumps to match source line <- same
  Multi-buffer occur match      Jumps to match source line <- same
  Outline Major/Minor Modes     Collapses, expands, and moves outline entries
  Man Apropos                   Displays man page entry    <- same
  Man Pages                     Follows cross refs, file refs and C code refs
  Buffer Menu                   Saves, deletes and displays buffers

Emacs Info Reader
  Menu Entry or Cross Ref       Jumps to referent          <- same
  Up, Next or Prev Header       Jumps to referent          Jumps to prior node
  File entry of Header          Jumps to top node          Jumps to (DIR) node
  End of current node           Jumps to next node         Jumps to prev node
  Anywhere else                 Scrolls up a windowful     Scrolls down a wind

Subsystems
  Calendar                      Scrolls or shows appts     Scrolls/marks dates
  Dired Mode                    Views and deletes files from directory listing
  GNUS News Reader              Toggles group subscriptions, gets new news,
                                  and browses articles
  Mail reader and Summaries     Browses, deletes and expunges messages
  OO-Browser                    Browses classes and elements
  Tar Mode                      Views and edits files from tar archive files

Any other context (defaults)    Hyperbole top menu         Smart Key summary
==============================================================================

   Note how the last line in the table explains the default behavior of
the Smart Keys.  That is what they do when they cannot find a context
match at your current location.  See the documentation for the variables
ACTION-KEY-DEFAULT-FUNCTION and ASSIST-KEY-DEFAULT-FUNCTION for
information on how to customize the behavior of the Smart Keys within
default contexts.

   A prime design criterion of Hyperbole's user interface is that one
should be able to see what an operation will do before using it.  The
Assist Key shows you what a button or minibuffer menu item will do
before you activate it.   Hyperbole also shows the result of directly
selecting an argument value with the mouse, to provide feedback as to
whether the right item has been selected.  A second click is necessary
before an argument is accepted and processed.

   When you use a mouse and you want to find out what either of the
Smart Keys does within a context, depress the one you want to check on
and hold it down, then press the other and release as you please.  A
help buffer will pop up explaining the actions that will be performed
in that context, if any.  A press of either Smart Key at the end of that
help buffer will restore your display to its configuration prior to
invoking help.

   By default (if HKEY-INIT is left set equal to `t' in `hsite.el'),
then {`C-h A'} will display this same context-sensitive help for the
Action Key while {`C-u C-h A'} will display the help for the Assist
Key.  Note that {`C-h a'} will perform a function unrelated to
Hyperbole, so you must press the shift key when you hit the `A'
character.

   When Hyperbole is installed, a key may be bound which allows you to
switch between the Smart Key mouse bindings and your prior ones.  `C-h
w hmouse-toggle-bindings <RET>' should show you any key which performs
this command.  If no key binding has been established or if you prefer
one of your own, simply select a key and bind it within your `~/.emacs'
file.  For example, `(global-set-key "\C-ct" 'hmouse-toggle-bindings)'.


File: hyperbole.info,  Node: Menus,  Next: Entering Arguments,  Prev: Smart Keys,  Up: Top

5 Menus
*******

Under InfoDock, XEmacs, and Emacs 19, pulldown and popup menus are
available to invoke Hyperbole commands, including those from the rolodex
and the outliner.  These menus operate like any other X window menus.
Use the Quit command on the Hyperbole menubar menu to get rid of the
menu if you do not need it.  Invoking Hyperbole again will add the menu
back to the menubar.

   This section discusses only the specialized "minibuffer menus" that
appear in the minibuffer window and that work with all Emacs versions.
Minibuffer menu items may be selected from either the keyboard or via
mouse clicks.  When used with the keyboard, they provide rapid command
access similar to key bindings.

   The top level menu is invoked from a key given in your `hsite.el'
file (by default, {`C-h h'}) or via an Action Key press in a location
with no other action defined.  The menu will appear in the minibuffer
and should look mostly like so:


     Hy4>  Act Butfile/ Doc/ Ebut/ Gbut/ Hist Ibut/ Msg/ Otl/ Rolo/ Win/

The above menu items can be summarized as follows:

*Act*
     Perform the action associated with any button at point or prompt
     for the name of an explicit button to activate if point is not on
     one.

*Butfile/*
     Display a local or global file of buttons, providing easy access.
     `HYPB' for a local button file and `~/.hyperb/HYPB' for your
     global file.  These are good places to start your button creation
     testing.

*Ebut/*
     All explicit button commands.

*Doc/*
     Hyperbole documentation quick access.  Contains Types/ submenu for
     documentation on Hyperbole implicit button and action types.

*Gbut/*
     All global button commands.  Global buttons are accessed by name
     rather than by direct selection.

*Hist*
     Jumps back to last position in button traversal history.

*Ibut/*
     All implicit button commands.

*Msg/*
     Hyperbole-specific mail and news messaging support commands.  Use
     this to send mail to the Hyperbole discussion list or to
     add/modify your entry on a Hyperbole mail list.

*Otl/*
     Autonumbered, structured outliner and hyper-node manager commands.
     *Note Outliner::.

*Rolo/*
     Hierarchical, multi-file rolodex lookup and edit commands.  *Note
     Rolodex::.

*Win/*
     Window configuration management such as adding and restoring window
     configurations by name. *Note Window Configurations::.


   All menu items are selected via the first character of their names
(letter case does not matter) or via a press of the Action Key.  "/" at
the end of an item name indicates that it brings up a sub-menu.  A press
of the Assist Key on an item displays help for the item, including the
action that it performs.

   While a menu is active, to re-activate the top-level Hyperbole menu,
you must use {`C-t'}.  This allows you to browse the submenus and then
return to the top.  You can quit without selecting an item by using
{`q'}.  {`C-g'} aborts whether you are at a menu prompt or any other
Hyperbole prompt.


File: hyperbole.info,  Node: Entering Arguments,  Next: Outliner,  Prev: Menus,  Up: Top

6 Entering Arguments
********************

Many Hyperbole commands prompt you for arguments.  The standard
Hyperbole user interface has an extensive core of argument types that it
recognizes.  Whenever Hyperbole is prompting you for an argument, it
knows the type that it needs and provides some error checking to help
you get it right.  More importantly, it allows you to press the Action
Key within an entity that you want to use as an argument and it will
grab the appropriate thing and show it to you at the input prompt
within the minibuffer.  If you press the Action Key again at the same
point (click with a mouse) on the same thing again, it accepts the
entity as the argument and moves on.  Thus, a double click registers a
desired argument.  Double-quoted strings, pathnames, mail messages,
Info nodes, dired listings, buffers, numbers, completion items and so
forth are all recognized at appropriate times.  All of the argument
types mentioned in the documentation for the Emacs Lisp `(interactive)'
function are recognized.  Experiment a little and you will quickly get
used to this direct selection technique.

   Wherever possible, standard Emacs completion is offered, see *Note
Completion: (emacs)Completion.  Remember to use {`?'} to see what your
possibilities for an argument are.  Once you have a list of possible
completions on screen, you can double click the Action Key on any one
to enter it as the argument.


File: hyperbole.info,  Node: Outliner,  Next: Rolodex,  Prev: Entering Arguments,  Up: Top

7 Outliner
**********

The Hyperbole outliner, also known as the Koutliner (pronounced
Kay-outliner), produces structured, autonumbered documents composed of
hierarchies of cells.  Each "cell" has two identifiers, a "relative
identifier" indicating its present position within the outline and a
"permanent identifier" called an "idstamp", suitable for use within
hyperlink references to the cell.  The idstamp is typically not
displayed but is available when needed.  *Note Autonumbering::.

   Cells also store their time of creation and the user who created the
cell.  User-defined attributes may also be added to cells.  *Note Cell
Attributes::.

   The outliner works only under GNU Emacs version 19 or higher, XEmacs
version 19.9 or higher or under InfoDock.  You can tell whether you are
running a version of Emacs which supports the outliner by hitting {`C-h
h'} to display the Hyperbole menu.  If you see an `Otl/' entry in the
menu, then the outliner is available.  Otherwise, the outliner does not
work with your version of Emacs, so this section of the manual will not
be of interest to you.  (The same is true of the Hyperbole/Outline
pulldown menu; if it appears, the outliner is available for use.)

   This chapter expands on the information given in `EXAMPLE.kotl' file
included with Hyperbole.  Use {`C-h h o e'} to display that file.  It
is an actual outline file that explains major outliner operations.  You
can test out the viewing and motion commands with this file.  If you
want to experiment with editing operations, use {`C-x C-w'} to write
the outline to a temporary file such as, `/tmp/e.kotl', and then use
{`C-x C-q'} to make the outline editable.

   *Note Outliner Keys::, for a full summary of the key bindings and
commands available in the outliner.

* Menu:

* Menu Commands::
* Creating Outlines::
* Autonumbering::
* Idstamps::
* Editing::
* Viewing::
* Links::
* Cell Attributes::
* Outliner History::


File: hyperbole.info,  Node: Menu Commands,  Next: Creating Outlines,  Prev: Outliner,  Up: Outliner

7.1 Menu Commands
=================

The Otl/ menu entry on the Hyperbole top-level menu provides access to
a number of major outliner commands:

     Menu Item    Command                    Description
     ====================================================================
     All          kotl-mode:show-all         Expand all cells
     Blanks       kvspec:toggle-blank-lines  Toggle blank lines on or off
     Create       kfile:find                 Edit or create an outline
     Downto       kotl-mode:hide-sublevels   Hide cells deeper than a level
     Examp        <sample outliner file>     Show self-descriptive example
     Hide         kotl-mode:hide-tree        Hide tree with root at point
     Info         <outliner documentation>   Show outliner manual section
     Kill         kotl-mode:kill-tree        Kill the current tree
     Link         klink:create               Create a link to another cell
     Overvw       kotl-mode:overview         Show first line of each cell
     Show         kotl-mode:show-tree        Show tree with root at point
     Top          kotl-mode:top-cells        Collapse to top-level cells
     Vspec        kvspec:activate            Set a view specification
     ====================================================================


File: hyperbole.info,  Node: Creating Outlines,  Next: Autonumbering,  Prev: Menu Commands,  Up: Outliner

7.2 Creating Outlines
=====================

In addition to the Otl/Create menu item, you can create and experiment
with outline files simply by finding a file, {`C-x C-f'} with a `.kotl'
suffix.  `.kot' will also work for DOS or Windows-impaired users.

   When a new koutline is created, an invisible root cell is created.
Its permanent and relative ids are both 0, and it is considered to be at
level 0 in the outline.  All visible cells in the outline are at level 1
or deeper, and thus are descendants of this root cell.  Some koutliner
commands prompt for cell numbers as arguments.  An argument of 0 makes
commands operate upon the entire outline.

   An initial level 1 cell is also created to make it easy to start
entering text in the outline.  A koutline always has at least one
visible cell in it.

   *Note Autonumbering::, which explains how cells are labeled
according to their respective levels in the outline and how these
labels are updated as the structure of the outline changes.


File: hyperbole.info,  Node: Autonumbering,  Next: Idstamps,  Prev: Creating Outlines,  Up: Outliner

7.3 Autonumbering
=================

*Note Adding and Killing::, which explains how to add new cells to or
remove cells from a koutline.  As you do this, or as you promote or
demote cells within the outline, the labels preceding the contents of
each cell automatically update to reflect the new structure.  These
labels are also known as "autonumbers" and as "relative ids" because
they change as the structure changes.

   The outline structure is shown by these labels and by the
indentation of each outline level.  Normally, each deeper level is
indented another three characters, to reflect the nesting.

   The default autonumbers are called "alphanumeric labels" because
they alternate between using numbers and letters to distinguish each
successive level.  Each alphanumeric label uniquely identifies a cell's
position in an outline, so that there is no need to scan back to prior
cells to see what the current section number of an outline is.  This is
similar to a legal numbering scheme but without all the period
characters between level numbers.  As an example, 1b3 is equivalent to a
legal label of 1.2.3.  Both refer to the 3rd cell at level 3, below the
2nd child of the first cell at level 1.  Said another way, this is the
3rd child of the 1st cell's 2nd child.  In other words, it is easier to
visualize hierarchies than to talk about them.

   Alphanumeric labels are the default because they are shorter and
easier to read aloud than equivalent legal ones.  They also simplify
distinguishing between even and odd level labels because of the
alternating character set.

   You can change the labeling scheme used in a particular outline with
the command {`C-c C-l'}.  A {`?'} then will show all of your options.
Legal labels, partial alpha labels (single level autonumbering where
only the last part of the level number is shown, as commonly seen in
other outliner products), idstamps (permanent cell ids), and star
outline level labels (Emacs asterisk-based outline labeling) are all
available.  Or you may choose to turn autonumbering off.  Cells are
still indented to reflect the outline structure whether or not labels
are displayed.

   A cell label is normally followed by two spaces, called the "label
separator", prior to the start of the cell contents.  You can change the
separator with for the current outline with {`C-c M-l'}.  {`C-u C-c
M-l'} will additionally change the default separator value used when
new outlines are created (for the current session only).  For example,
use the value ". " to get a trailing period after each cell label.  The
separator must be at least two characters long but may be longer.

   If you find a separator that you prefer for all outlines, change the
separator setting permanently by adding the following line to your Emacs
initialization file, `~/.emacs', substituting for `your-separator':

     (setq kview:default-label-separator "your-separator")


File: hyperbole.info,  Node: Idstamps,  Next: Editing,  Prev: Autonumbering,  Up: Outliner

7.4 Idstamps
============

Idstamps (permanent ids) are associated with each cell and can be used
in hyperlinks that are maintained as cells are reordered in a file.
*Note Links::.  Idstamps may also be displayed in place of the outline
level relative ids.  Use {`C-c C-l id RET'}.

   An idstamp counter for each outline starts at 0 and is incremented by
one each time a cell is added to the outline.  This idstamp stays with
the cell no matter where it is moved within the outline.  If the cell is
deleted, its idstamp is not reused.

   The 0 idstamp is always assigned to the root node of the entire
outline.  This node is never visible within the outline, but is used so
that the outline may be treated as a single tree when needed.  Idstamps
always begin with a 0, as in 012, to distinguish them from relative ids.


File: hyperbole.info,  Node: Editing,  Next: Viewing,  Prev: Idstamps,  Up: Outliner

7.5 Editing
===========

You edit text and move around in the Koutliner just as you would in any
other Emacs buffer, except when you want to deal with the structural
components of an outline.  Within the contents of a cell, all of your
standard editing keys should work properly.  You can just type in text
and the left and right margins of the lines will be maintained for you.
*Note Filling::, for the times when you need to refill a paragraph or to
control when filling occurs.

   Don't invoke editing commands with {`M-x command-name <RET>'} since
the Koutliner uses special differently named commands made to act like
the regular editing commands but which account for the structure and
indentation in koutlines.

   You can use the mouse to select parts of the contents of a single
cell for editing.  But don't drag across cell boundaries and then edit
the selected region, since that can destroy the outline structure.

* Menu:

* Adding and Killing::
* Moving Around::
* Relocating and Copying::
* Filling::
* Transposing::
* Splitting and Appending::
* Inserting and Importing::


File: hyperbole.info,  Node: Adding and Killing,  Next: Relocating and Copying,  Prev: Editing,  Up: Editing

7.5.1 Adding and Killing
------------------------

{`C-j'} adds a new cell as a successor sibling of the current cell,
that is, the next cell at the same level as the current cell.  If you
enter a positive number as a prefix argument, that number of cells will
be inserted, all at the same level.  {`C-u C-j'} is handled specially.
It adds a single cell as a child of the current cell.  {`C-c a'} does
the same thing.  {`C-c p'} adds the cell as the successor of the
current cell's parent.

   {`C-c C-k'} kills the current cell and its entire subtree.  {`C-c
k'} kills the contents of a cell from point through the end of the
cell; it does not remove the cell itself.  {`C-u C-c k'} kills the
entire contents of the cell regardless of the location of point.  You
may then yank the contents into another cell or another buffer with
{`C-y'}.


File: hyperbole.info,  Node: Relocating and Copying,  Next: Moving Around,  Prev: Adding and Killing,  Up: Editing

7.5.2 Relocating and Copying
----------------------------

"Demotion" is the act of moving a tree down one or more levels in the
outline.  The new tree will become either the successor or the first
child of the cell which precedes it in the outline.  "Promotion" is the
inverse operation.  Note that trees (cells and their entire
substructure) are promoted and demoted, not individual cells.

   Trees may be demoted or promoted by pressing {<TAB>} or {`M-<TAB>'}
respectively, as in most outliners today.  {`M-0 <TAB>'} and {`M-0
M-<TAB>'} demote and promote trees and additionally refill each cell
that is not specially marked to prevent refilling.  *Note Filling::.  A
positive or negative prefix argument to these commands promotes or
demotes the tree up to a maximum of the number of levels given by the
argument.  The outline may not support movement of the tree by the
number of levels requested.

   For maximum flexibility in rearranging outlines, there are commands
that move or copy entire trees.  Each of these commands prompts for the
label of the root cell to move or copy and for second cell at the new
location for the moved or copied tree.  You can either accept the
default provided, type in the cell label or when a mouse is available,
simple double click with the Action Key on the contents of a cell.  The
Koutliner knows to use the cell's label in such cases.

   In these following commands, words delimited with <> represent the
arguments for which each command prompts.  Note how the use of prefix
arguments changes each command's behavior from insertion at the sibling
level to insertion at the child level.

`C-c c'
     Copy <tree> to be the successor of <cell>.  

`C-u C-c c'
     Copy <tree> to follow as the first child of <cell>.

`C-c C-c'
     Copy <tree> to be the predecessor of <cell>.  

`C-u C-c C-c'
     Copy <tree> to be the first child of the parent of <cell>.

`C-c m'
     Move <tree> to be the successor of <cell>.  

`C-u C-c m'
     Move <tree> to follow as the first child of <cell>.

`C-c C-m'
     Move <tree> to precede <cell>.  

`C-u C-c C-m'
     Move <tree> to be the first child of the parent of <cell>.

   If you have mouse support under Hyperbole, you can move entire trees
with mouse clicks.  Simply click the Assist Key within the indentation
to the left of a cell and you will be prompted for a tree to move.
Double click the Action Key within the contents the root cell of the
tree to move and then double click within the contents of the root cell
of the tree you want it to follow as a sucessor.

   Copying and moving only work within a single outline right now, so
don't try to use them to move trees across different outline files.
You can, however, copy an outline tree to a non-outline buffer with:

`C-c M-c'
     Copy  <tree> to a non-koutline buffer.  

`C-c @'
     Copy a <tree> to an outgoing mail message.


File: hyperbole.info,  Node: Moving Around,  Next: Filling,  Prev: Relocating and Copying,  Up: Editing

7.5.3 Moving Around
-------------------

In addition to normal Emacs movement commands, you can move within a
cell or from one cell or tree to another.

`C-c ,'
     Move to the beginning of the current cell.  

`C-c .'
     Move to the end of the current cell.

`C-c C-n'
     Move to the next visible cell, regardless of level.  

`C-c C-p'
     Move to the previous visible cell, regardless of level.

`C-c C-f'
     Move forward to this cell's successor, if any.  

`C-c C-b'
     Move backward to this cell's predecessor, if any.

`C-c C-d'
     Move to the first child of the current cell, if any.  

`C-c C-u'
     Move to the parent cell of the current cell, if any.

`C-c <'
     Move to the first sibling at the current level within this tree.  

`C-c >'
     Move to the last sibling at the current level within this tree.

`C-c ^'
     Move to the level 1 root cell of the current tree.  

`C-c $'
     Move to the last cell in the tree rooted at point, regardless of
     level.


File: hyperbole.info,  Node: Filling,  Next: Transposing,  Prev: Moving Around,  Up: Editing

7.5.4 Filling
-------------

Filling is the process of extending lines that are shorter than the
right margin and reducing lines which extend past the margin by moving
words among the lines.  Commands are provided to fill a paragraph within
a cell or a whole cell, which may have multiple paragraphs.

   {`M-q'} or {`M-j'} refills a paragraph within a cell so that its
lines wrap within the current margin settings.  {`C-c M-q'} or {`C-c
M-j'} refills all paragraphs within a cell.  {`C-M-q'} or {`C-M-j'}
refills all cells within a tree.  See your Emacs or InfoDock manual for
information on how to set the left and right margins.

   Set the variable, KOTL-MODE:REFILL-FLAG, to t if you want moving,
promoting, demoting, exchanging, splitting and appending cells to also
automatically refill each cell.  Generally, this is not recommended
since if you happen to move a cell that you have carefully formatted
and forgot to give it a `no-fill' property, your formatting will be
lost.


File: hyperbole.info,  Node: Transposing,  Next: Splitting and Appending,  Prev: Filling,  Up: Editing

7.5.5 Transposing
-----------------

The Koutliner move and copy commands rearrange entire trees.  The
following two commands, in contrast, exchange the locations of two
individual cells.

   {`C-c e'} prompts for two cell addresses and exchanges the cell
locations.

   {`C-c t'} does not prompt.  It exchanges the current and immediatly
prior cell, regardless of their levels.  If there is no prior cell it
exchanges the current and next cell.

   {`M-0 C-c t'} exchanges the cells in which point and mark fall.
{`C-c t'} with a non-zero numeric prefix argument, N, moves the current
tree past maximally the next N visible cells.  If there are fewer
visible, it makes the current cell the last cell in the outline.


File: hyperbole.info,  Node: Splitting and Appending,  Next: Inserting and Importing,  Prev: Transposing,  Up: Editing

7.5.6 Splitting and Appending
-----------------------------

You can split one cell into two adjacent sibling cells with {`C-c s'}.
This leaves the cell contents preceding point in the current cell,
minus any trailing whitespace, and moves the contents following point
to a new sibling cell which is inserted into the outline.  {`C-u C-c
s'} instead adds the new cell as the first child of the original cell,
rather than as its successor.

   All cell attributes in the original cell are propagated to the new
one, aside from the creation attributes and idstamp.

   {`C-c +'} appends the contents of a specified cell to the end of
another cell.  It has no effect on cell attributes, except that if one
cell has a `no-fill' attribute that prevents all but user requested
filling of a cell, then the cell appended to inherits this property.
This helps maintain any special formatting the appended text may have.


File: hyperbole.info,  Node: Inserting and Importing,  Prev: Splitting and Appending,  Up: Editing

7.5.7 Inserting and Importing
-----------------------------

The elements of another buffer or file may be inserted into a koutline
as a set of cells by using the {`C-x i'} command.  When prompted, you
may use a buffer name or file name from which to insert, though
completion is provided only for file names.

   The elements from the original buffer are converted into kcells and
inserted as the successors of the current cell.  If {`C-u C-x i'} is
used, they are instead inserted as the inital children of the current
cell.

   See the documentation for the variables, kimport:mode-alist and
kimport:suffix-alist, for information on mode and suffix-specific
conversions performed on file elements before they are inserted.  This
same conversion process applies if you invoke {`M-x kotl-mode RET'} in
a non-koutline buffer or if you perform a generic file import as
described later in this section.

   Use {`M-x kotl-mode:insert-file-contents RET'} to insert the entire
contents of a file into the current cell at the location of point.

   The outliner presently supports conversion of three types of files
into koutline files.  You can choose to import a file into an existing
koutline, following the tree at point, or to create a new koutline of
the imported file contents.  {`M-x kimport:file RET'} will select the
importation type based on the buffer or file name suffix of the file to
import.

   If you want to convert a buffer from some other mode into a koutline
and then want to save the converted buffer back to its original file,
thereby replacing the original format, then use {`M-x kotl-mode RET'}
to convert the buffer into a koutline.  Remember that you will lose the
old format of the buffer when you do this.

   Use one of the following commands if you really need explicit
control over the type of importation used on some text.  With these
commands, your original file remains intact.

   Use {`M-x kimport:text RET'} and you will be prompted for a text
buffer or file to import and the new koutline buffer or file to create
from its text.  It will also import the contents, attributes and level
structure of cells from a koutline.

   Star outlines are standard Emacs outlines where each entry begins
with one or more asterisk characters.  Use {`M-x kimport:star-outline
RET'} and you will be prompted for the star outline buffer or file to
import and the new koutline buffer or file to create.

   (Skip this if you are unfamiliar with the Augment system.)  Files
exported from the Augment system as text often have alphanumeric
statement identifiers on the right side.  You can import such files
while maintaining there outline structure.  Use {`M-x
kimport:aug-post-outline RET'} and you will be prompted for the Augment
buffer or file to import and the koutline to create.


File: hyperbole.info,  Node: Viewing,  Next: Links,  Prev: Editing,  Up: Outliner

7.6 Viewing
===========

The Koutliner has very flexible viewing facilities to allow you to
effectively browse and study large amounts of material.

* Menu:

* Hiding and Showing::
* View Specs::


File: hyperbole.info,  Node: Hiding and Showing,  Next: View Specs,  Prev: Viewing,  Up: Viewing

7.6.1 Hiding and Showing
------------------------

Individual cells, branches, or particular levels in the outline may be
hidden or shown.  These commands work even when an outline buffer is
read-only, e.g. when its file is not checked out of a version control
system yet, so that you can get effective views of an outline without
editing it.  Some of these commands affect the current view spec, *Note
View Specs::.

`C-c C-h'
     Hide (collapse) the tree rooted at point.  

`C-c C-s'
     Show (expand) the tree rooted at point.

`C-c C-a'
     Show (expand) all of the cells in the outline.  

`C-x $'
     Show all of the cells down to a particular <level>.  You are
     prompted for the level or a prefix argument may be given.

`C-M-h'
     Hide the subtree at point, excluding the root cell.  

`M-x kotl-mode:show-subtree'
     Show the subtree at point.  Use {`C-c C-s'} to achieve a similar
     effect.  The only difference is that it will expand the root cell
     too.

`C-c C-o'
     Show an overview of the outline by showing only the first line of
     every cell.  This also turns off blank lines between cells to
     maximize your view of the outline.  

`C-c C-t'
     Show a top-level view of the outline by showing only the first
     line of each level one cell.  This does not turn off blank lines.

   A click or a press of the Action Key within a cell's body, but not
on a Hyperbole button, toggles between hiding and showing the tree
rooted at point.  Try it with either your mouse or with {`M-<RET>'}.


File: hyperbole.info,  Node: View Specs,  Prev: Hiding and Showing,  Up: Viewing

7.6.2 View Specs
----------------

"View specifications" (view specs, for short) are short codes used to
control the view of a koutline.  The view specs in effect for an
outline are always displayed in the modeline of the outline's window,
following the outline buffer name, unless the variable, KVSPEC:STRING,
has been set to `nil' to disable view spec modeline display.  The
modeline display appears as <|viewspec> so that you can easily pick
them out.  The | (pipe character) is also used in links that specify
view specs to indicate the start of a view spec sequence.  *Note
Links::.

   The current view spec is saved whenever the outline is saved.  The
next time the outline is read in, this will be the initial view.

   The rest of this section documents the the view spec characters that
are presently supported and explains how to invoke a view spec.  There
is no user-level way to add your own view spec characters, so all
character codes are reserved for future use.

   {`C-c C-v'} prompts for a new view spec setting in which the
following codes are valid.  Any invalid characters in a view spec are
ignored.  Characters are evaluated in an order meant to do the right
thing, even when you use conflicting view spec characters.  The
standard initial view spec is <|ben>.

`a'
     Show all cell levels and all lines in cells.

`b'
     Turn on blank lines between cells.  Without this character, blank
     lines will be turned off.  You can also use the {`C-c b'} key
     binding to toggle line numbers on and off independent of any other
     view settings.

`cN'
     Hide any lines greater than N in each cell.  0 means don't cutoff
     any lines.

`e'
     Show ellipses when some content of a cell or its subtree is hidden.

`lN'
     Hide cells at levels deeper than N.  0 means don't hide any cells.

`n'
     Turn on the default label type, as given by the variable,
     KVIEW:DEFAULT-LABEL-TYPE.  Normally, this is alphanumeric labels.  

`n0'
     Display idstamps.  

`n1'
     Display alpha labels.  

`n2'
     Display partial alpha labels (don't use this, as full alpha labels
     are better).  

`n.'
     Display legal labels.  

`n*'
     Display star labels.  A level three cell would have three
     asterisks as a label, for example.  

`n~'
     Turn off labels.  (n viewspec is removed from modeline).

   As a test, use {`C-h h o e'} to display the example koutline.  Then
use {`C-c C-v'} to set a view spec of `c2l1'.  This will turn off blank
lines, clip each cell after its second line, and hide all cells below
level one.


File: hyperbole.info,  Node: Links,  Next: Cell Attributes,  Prev: Viewing,  Up: Outliner

7.7 Links
=========

Hyperlinks may be embedded in cells and may refer to other cells or
external sources of information.  Explicit Hyperbole buttons may be
created as usual via mouse drags, *Note Creation Via Action Key Drags:
By Dragging.  A "klink" is a special implicit link button, delimited by
<> separators, that jumps to a specific outline cell.  This section
discusses klinks.

   Press the Action Key over a klink to follow it.  This will flash the
klink as a button and then will display its referent in the other
window.  If the klink contains a view spec, that will be used when the
referent is displayed.

   There are a number of easy ways to insert klinks into koutlines.  If
you have mouse support under Hyperbole, simply click the Action Key
within the indentation to the left of a cell text.  If you then double
click on some cell, a link to that cell will be inserted where you
started.  From a keyboard, use {`C-c l'} when in a koutline or {`C-h h o
l'} when not in a koutline to insert a klink.  Since klinks are
implicit buttons, you can type in the text of the klink just as you see
it in the examples below and it will work exactly as if it had been
entered with the insert link command.

There are basically three forms of klinks:

*internal
     <@ 2b=06> is an internal klink, since it refers to the koutline in
     which it is embedded.  When activated, it jumps to the cell within
     the current outline which has permanent id `06' and relative id
     `2b'.  <@ 06> does the same thing, as does <@ 2b>, though this
     latter form will not maintain the link properly if the cell is
     moved elsewhere within the outline.  The form, <@ 2b=06 |ben>
     additionally sets the view spec of the current outline back to the
     default value, with a blank line between each cell and all levels
     and lines of cells displayed.

*external
     The second klink format is an external link to another koutline,
     such as, <EXAMPLE.kotl, 3=012 |c1e>, which displays the named
     file, starting at the cell 3 (whose permanent identifer is 012),
     with the view specification of: blank lines turned off, cutoff
     after one line per cell, and show ellipses for cells or trees
     which are clipped.

*view spec
     The third format simply allows you to set a view spec for the
     current koutline.  For example, <|ben>, when activated, sets the
     view in the current outline to display blank lines, ellipses
     following collapsed lines and standard alphanumeric numbering.


File: hyperbole.info,  Node: Cell Attributes,  Next: Outliner History,  Prev: Links,  Up: Outliner

7.8 Cell Attributes
===================

"Attributes" are named variables whose values are specific to a
particular outline cell.  Thus, each cell has its own attribute list.
Every cell has three standard attributes:

*idstamp
     The permanent id of the cell, typically used in cross-file
     hyperlinks that reference the cell.

*creator
     The e-mail address of the person who created this cell.

*create-time
     The time at which the cell was created.  This is stored in a form
     that allows for easy data comparisons but is displayed in a human
     readable format, such as "Jan 28 18:27:59 CST 1994".

   {`C-c C-i'} is the command to add an attribute to or to modify an
existing attribute in the cell at point.  Think of it as inserting an
attribute value.  To remove an attribute from cell, set its value to
`nil'.

   The `no-fill' attribute is special.  When added with a non-nil
value, it prevents moving, promoting, demoting, exchanging, splitting
and appending cells from refilling the cell, even if the variable,
KOTL-MODE:REFILL-FLAG, is set to t.  It does not prevent you from
invoking explicit commands that refill the cell.  *Note Filling::.

   The attribute lists for the cells in the tree rooted at point can be
displayed by pressing the Assist Key within the contents of a cell.

   {`C-c h'} prompts for a cell label and displays the cell's
attributes.  {`C-u C-c h'} prompts for a cell label and displays the
attributes for it and its subtree; use 0 as the kcell id to see
attributes for all visible cells in the outline.


File: hyperbole.info,  Node: Outliner History,  Prev: Cell Attributes,  Up: Outliner

7.9 Outliner History
====================

Much of the Hyperbole outliner design is based upon concepts pioneered
in the NLS/Augment system, `[Eng84a]'.  Augment treated documents as a
hierarchical set of nodes, called statements, rather than cells.  Every
Augment document utilized this intrinsic structure.

   The system could rapidly change the view of a document by collapsing,
expanding, generating, clipping, filtering, including or reordering
these nodes.  It could also map individual views to multiple workstation
displays across a network to aid in distributed, collaborative work.

   These facilities aided greatly in idea structuring,
cross-referencing, and knowledge transfer.  The Koutliner is a start at
bringing these capabilities back into the mainstream of modern
computing culture.


File: hyperbole.info,  Node: Rolodex,  Next: Window Configurations,  Prev: Outliner,  Up: Top

8 Rolodex
*********

Hyperbole includes a complete, advanced rolodex system, Wrolo, for
convenient management of hierarchical, record-oriented information.

   Hyperbole buttons may be included within rolodex records and then
manually activated whenever their records are retrieved.

   See the description at the top of the `wrolo.el' file for details on
programmatic interfacing to the rolodex.  The following subsections
explain use and basic customization of the rolodex.

* Menu:

* Rolo Concepts::
* Rolo Menu::
* Rolo Keys::
* Rolo Settings::


File: hyperbole.info,  Node: Rolo Concepts,  Next: Rolo Menu,  Prev: Rolodex,  Up: Rolodex

8.1 Rolo Concepts
=================

The rolodex manages and searches rolodex files.  A "rolodex file"
consists of an optional header which starts and ends with a line of
equal signs (at least three equal signs starting at the beginning of a
line), followed by any non-negative number of rolodex records.  You must
manually add a header to any rolodex file if you want it to have one.

Here is an example of a simple rolodex file.

     ==================================================================
                             PERSONAL ROLODEX
     <Last-Name>, <First>  <Email>        W<Work#>       F<Fax#>
     ==================================================================
     *   Smith, John       <js@hiho.com> W708-555-2001  F708-321-1492
             Chief Ether Maintainer, HiHo Industries
             10/24/95

   We call rolodex records, "entries".  Entries begin with a delimiter,
some number of `*' characters at the beginning of a line.  Entries may
be arranged in a hierarchy, where child entries begin with one more `*'
characters than do their parents.  Top level entries begin with a single
`*'.

   Beyond this initial delimiter, entries are completely free-form text.
It is best to use a "lastname, firstname" format, however, when adding
contact entries into a rolodex.  Then the rolodex system will
automatically keep your entries alphabetized as you enter them.  You'll
also be able to sort them whenever you desire.

   Any search done on the rolodex scans the full text of each entry.
During a search, the rolodex file header separator lines and anything in
between are appended to the buffer of matched entries before any entries
are retrieved from the file.  Whenever an entry is matched, it and all
of its descendant entries are retrieved.  If your Emacs version supports
textual highlighting, each search match is highlighted for quick, visual
location.

For example, a search on "Company" could retrieve the following:

     ==================================================================
                             COMPANY ROLODEX
     ==================================================================
     *    Company
     **     Manager
     ***      Underlings

Thus, searching for Company retrieves all listed employees.  Searching
for Manager turns up all Underlings.


File: hyperbole.info,  Node: Rolo Menu,  Next: Rolo Keys,  Prev: Rolo Concepts,  Up: Rolodex

8.2 Rolo Menu
=============

The Rolo/ menu entry on the Hyperbole top-level menu provides the user
interface to the rolodex.  The rolo menu provides access to the
following commands:

     Menu Item       Command               Description
     ====================================================================
     Add             rolo-add              Adds a rolodex entry
     Display         rolo-display-matches  Displays last matches again
     Edit            rolo-edit             Edits an existing rolodex entry
     Info                                  Displays Rolodex manual entry
     Kill            rolo-kill             Removes an entry from the rolodex
     Mail            rolo-mail             Mail to address following point
     Order           rolo-sort             Sorts all levels in rolodex
     RegexFind       rolo-grep             Finds all entries containing
                                             a regular expression
     StringFind      rolo-fgrep            Finds all entries containing
                                             a string
     WordFind        rolo-word             Finds all entries containing
                                             a string of whole words
     Yank            rolo-yank             Inserts first matching rolodex
                                             entry at point
     ====================================================================

   A prefix argument used with either of the find commands listed above
limits the search to a maximum number of matches given by the argument.
The search is terminated whenever that number of matches is found.

   For any of the above commands that prompt for a name, you may use the
form parent/child to locate a child entry below a parent entry.  So for
a rolodex which looked like so:

     *    Company
     **     Manager
     ***      Underlings

You could edit the Underlings entry by identifying it as
Company/Manager/Underlings.  Do not use this hierarchical notation in
search expressions since the whole rolodex will be searched anyway.
Thus, "Underlings" as a search pattern will find an entry containing
"Underlings" at any level in a hierarchy, like so:

     ***      Underlings


File: hyperbole.info,  Node: Rolo Keys,  Next: Rolo Settings,  Prev: Rolo Menu,  Up: Rolodex

8.3 Rolo Keys
=============

Use the {`e'} key to edit the entry at point within the rolodex source
file.

   After a rolodex search is performed, point is left in the "rolodex
match buffer", `*Rolodex*', which uses `wrolo-mode' to simplify
browsing many rolodex matches.  Press {`?'} when in the match buffer
for a summary of available keys.

   If your Emacs version supports textual highlighting, each search
match is highlighted for quick, visual location.  {<TAB>} moves point
forward to successive spans of text which match the search expression.
{`M-<TAB>'} or {`r'} moves point backward to earlier matches.  These
keys allow you to quickly find the matching entry of most interest to
you if your search expression failed to narrow the matches sufficiently.

   If you want to extend the match expression with some more characters
to find a particular entry, use {`M-s'}, which performs an interactive
search forward for the match expression.  You can add or delete
characters to this expression to find different occurences.  {`C-r'}
will reverse the direction of the search.

   Single key outlining commands are also available for browsing
matches.  If your search matches a large number of entries, use {`t'}
to get a top-level overview of all the entries.  Each entry is
collapsed so that only its first line shows.  Press {`s'} to show
(expand) the entry at point.  Use {`h'} to hide (collapse) the entry
again.  Press {`a'} to expand all entries in the buffer.

   Many other keys are defined to help you move through matching
entries.

`b'
     Move to the previous entry at the same level as the current entry.  

`f'
     Move to the next entry at the same level as the current entry.  

`n'
     Move to the next entry at any level.  

`p'
     Move to the previous entry at any level.  

`u'
     Move the the previous entry one level up.  

`.'
`<'
     Move to the beginning of the buffer.  

`,'
`>'
     Move to the end of the buffer.  

`<DEL>'
     Scroll backward a windowful.  

`<SPC>'
     Scroll forward a windowful.

   Once you have found an entry of interest and you want to remove the
rolodex match buffer, use {`q'} to quit.  This will restore your
current frame to its state prior to the rolodex search.


File: hyperbole.info,  Node: Rolo Settings,  Prev: Rolo Keys,  Up: Rolodex

8.4 Rolo Settings
=================

If textual highlighting is available in your Emacs on your current
display type, the rolodex uses the value of ROLO-HIGHLIGHT-FACE as the
face to use to highlight search matches.

   The buffers containing the rolodex files are not killed after a
search on the assumption that another search is likely to follow within
this Emacs session.  You may wish to change this behavior with the
following setting: `(setq rolo-kill-buffers-after-use t)'.

   After an entry is killed, the modified rolodex file is automatically
saved.  If you would rather always save files yourself, use this
setting: `(setq rolo-save-buffers-after-use nil)'.

   When adding an entry from within a buffer containing a mail message,
the rolodex add function will extract the sender's name and e-mail
address and prompt you with the name as a default.  If you accept it,
it will enter the name and the email address using the format given by
the ROLO-EMAIL-FORMAT variable.  See its documentation if you want to
change its value.

   The files used in any rolodex search are given by the ROLO-FILE-LIST
variable, whose default value is `("~/.rolodex.otl")', so that searches
initially scan only your personal rolodex.  Any entries added to this
list should be file pathnames.  If a file in the list does not exist or
is not readable, it is skipped.  Files are searched in the order in
which they appear in the list.  In general, you should leave your
personal rolodex file as the first entry in the list, since this is the
only file to which the rolo menu Add command adds entries.

   The rolodex entry start delimiter is given by the regular expression
variable, ROLO-ENTRY-REGEXP, whose default value is "^\*+".

   A rolodex file may begin with an optional header section which is
copied to the match display buffer whenever any matches are found
during a search.  The start and end lines of this header are controlled
by the regular expression variable, ROLO-HDR-REGEXP, whose default
value is "^===".  This allows lines of all equal signs to visually
separate matching entries from multiple files retrieved from a single
search.


File: hyperbole.info,  Node: Window Configurations,  Next: Developing with Hyperbole,  Prev: Rolodex,  Up: Top

9 Window Configurations
***********************

Hyperbole includes the `wconfig.el' package which lets you save and
restore window configurations, i.e. the window layout and buffers
displayed within an Emacs frame.  This is useful to save a particular
working context and then to jump back to it at a later time during an
Emacs session.  It is also useful during demonstrations to pull up many
informational artifacts all at once, e.g. all of the windows for a
particular subsystem.  None of this information is stored between Emacs
sessions, so your window configurations will last only through a single
session of use.

   The wconfig library provides two distinct means of managing window
configurations.  The first means associates a name with each stored
window configuration.  The name can then be used to retrieve the window
configuration later.  The second means uses a ring structure to save
window configurations and then allows browsing through the sequence of
saved configurations.

   The Win/ menu entry on the Hyperbole top-level menu displays a menu
of window configuration commands:


     WinConfig>  AddName  DeleteName  RestoreName  PopRing  SaveRing  YankRing

     Menu Item       Command                   Description
     ====================================================================
     AddName         wconfig-add-by-name       Name current wconfig
     DeleteName      wconfig-delete-by-name    Delete wconfig with name
     RestoreName     wconfig-restore-by-name   Restore wconfig by name

     PopRing         wconfig-delete-pop        Restore and delete wconfig
     SaveRing        wconfig-ring-save         Store wconfig to ring
     YankRing        wconfig-yank-pop          Restore next wconfig
     ====================================================================

   Saving and restoring window configurations by name is the easiest
method, but it requires that you input the chosen name from the
keyboard.  The ring commands permit saving and restoring through mouse
interaction only, if so desired.  The prior section, *Note Smart Keys::,
mentions how to save and restore window configurations with the Smart
Keys.  Since the ring commands are a bit more complex than their by-name
counterparts, the following paragraphs explain them in more detail.

   Wconfig creates a ring structure that operates just like the Emacs
KILL-RING, *Note Kill Ring: (emacs)Kill Ring, but its elements are
window configurations rather than text regions.  One can add an element
to the ring based upon the current window configuration.  After several
elements are in the ring, one can walk through all of them in sequence
until the desired configuration is restored.

   SaveRing executes the `wconfig-ring-save' command which saves the
current window configuration to the ring.

   YankRing executes the `wconfig-yank-pop' command.  It restores the
window configuration from the currently pointed to configuration in the
ring.  It does not delete this configuration from the ring but it does
move the pointer to the prior ring element.  Repeated calls to this
command thus restore successive window configurations until the ring
pointer wraps around.  Simply stop when a desired configuration appears
and use {`q'} to quit from the minibuffer menu.

   PopRing calls the `wconfig-delete-pop' command.  It is used to
restore a previously saved configuration and at the same time delete it
from the ring.  Simply stop when a desired configuration appears and
use {`q'} to quit from the minibuffer menu.

   The maximum number of elements the ring can hold is set by the
WCONFIG-RING-MAX variable whose default is 10.  Any saves beyond this
value cause deletion of the oldest element in the ring before a new one
is added.


File: hyperbole.info,  Node: Developing with Hyperbole,  Next: Glossary,  Prev: Window Configurations,  Up: Top

10 Developing with Hyperbole
****************************

This chapter is only for people who are familiar with Emacs Lisp and
wish to customize Hyperbole, to extend it, or to develop other systems
using Hyperbole as a base.

* Menu:

* Hook Variables::
* Creating Types::
* Explicit Button Technicalities::
* Encapsulating Systems::
* Embedding Hyperbole::


File: hyperbole.info,  Node: Hook Variables,  Next: Creating Types,  Prev: Developing with Hyperbole,  Up: Developing with Hyperbole

10.1 Hook Variables
===================

Hyperbole provides a number of hook variables that allow you to adjust
its basic operations to meet your own needs, without requiring you to
change the code for those operations.

   We find it best to always set the value of hook variables either to
nil or to a list of function names of no arguments, each of which will
be called in sequence when the hook is triggered.

   Given the name of a function, a Hyperbole hook variable triggered
within that function has the same name as the function with a `-hook'
appended.  Hyperbole provides the following hook variables:

HYPERB:INIT-HOOK
     For customization at Hyperbole initialization time.  Use this to
     load any personal Hyperbole type definitions you might have.  It
     is run after Hyperbole support code is loaded but before Hyperbole
     session initializations take place.

ACTION:ACT-HOOK
     Run before each Hyperbole button activation.  The variable
     HBUT:CURRENT contains the button to be activated when this is run.

EBUT:CREATE-HOOK
     To add to the Hyperbole explicit button creation process.

EBUT:DELETE-HOOK
     To add to the Hyperbole explicit button deletion process.

EBUT:MODIFY-HOOK
     Executed when an explicit button's attributes are modified.

HIBTYPES:BEGIN-LOAD-HOOK
     Executed prior to loading of standard Hyperbole implicit button
     types.  Used to load site-specific low priority implicit button
     types since lowest priority ibtypes are loaded first.

HIBTYPES:END-LOAD-HOOK
     Executed after loading of standard Hyperbole implicit button types.
     Used to load site-specific high priority implicit button types
     since highest priority ibtypes are loaded last.

HTYPE:CREATE-HOOK
     Executed when a Hyperbole type (e.g. action type or implicit button
     type) is added to the environment.

HTYPE:DELETE-HOOK
     Executed when a type is deleted from the environment.

KOTL-MODE-HOOK
     Executed when a Koutline is created or read in or when kotl-mode is
     invoked.

WROLO-DISPLAY-HOOK
     Executed when rolodex matches are displayed.

WROLO-MODE-HOOK
     Executed when a rolodex match buffer is created and put into
     wrolo-mode.

WROLO-YANK-REFORMAT-FUNCTION
     A variable whose value may be set to a function of two arguments,
     START and END, indicating the region of the rolodex entry yanked
     into the current buffer by the rolo-yank command.  The function
     may reformat this region to meed user-specific needs.


Hyperbole also makes use of a number of external Emacs hook variables.

FIND-FILE-HOOKS
     This is called whenever a file is read into a GNU Emacs buffer.
     Hyperbole uses it to highlight any buttons within files when run
     under any NEXTSTEP or X window system-based versions of GNU Emacs.

WRITE-FILE-HOOKS
     This is called whenever a GNU Emacs buffer is written to a file.
     Hyperbole uses it to save any modified button data associated with
     the file's directory.

     Hyperbole mail and news facilities also utilize a number of
     external hook variables.  These hide button data and highlight
     buttons if possible.  See the various support files for details.


File: hyperbole.info,  Node: Creating Types,  Next: Explicit Button Technicalities,  Prev: Hook Variables,  Up: Developing with Hyperbole

10.2 Creating Types
===================

To define or redefine a single Hyperbole type, you may either:

   * move your Emacs point to within the type definition and use
     {`C-M-x'} `(eval-defun)' (only works in Emacs Lisp mode);

   * or move your point to the end of the last line of the type
     definition and use {`C-x C-e'} `(eval-last-sexp)' (works in most
     modes).

   The functions from the `htype' class may be applied to any Hyperbole
types, if needed.

   The following subsections explain the specifics of Hyperbole type
definitions which are beyond standard practice for Emacs Lisp
programming.  See the definitions of the standard types in `hactypes.el'
and `hibtypes.el' for examples.

* Menu:

* Action Type Creation::
* Implicit Button Types::


File: hyperbole.info,  Node: Action Type Creation,  Next: Implicit Button Types,  Prev: Creating Types,  Up: Creating Types

10.2.1 Action Type Creation
---------------------------

New forms of explicit buttons may be created by adding new action types
to a Hyperbole environment.  The file, `hactypes.el', provides many
examples of working action types.

   An action type is created, i.e. loaded into the Hyperbole
environment, with the `(defact)' function (which is an alias for
`(actype:create)').  The calling signature for this function is given
in its documentation; it is the same as that of `(defun)' except that a
documentation string is required.  (An interactive calling form is also
required if the action type has formal parameters and is to be used in
explicit button definitions.  Implicit buttons never use an action
type's interactive form.  It is good practice to include an interactive
form since the type creator cannot know how users may choose to apply
the type.)

   An action type's parameters are used differently than those of a
function being called.  Its interactive calling form is used when an
explicit button is created to prompt for type-specific button
attributes.  The rest of its body is used when a button with that action
type is activated.  Then the button attributes together with the action
type body are used to form an action that is executed in response to the
button activation.  The action's result is returned to the action caller
unless it returns nil, in which case t is returned to the caller to
ensure that it registers the performance of the action.

   An action type body may perform any computation using Emacs Lisp and
Hyperbole functions.

   The interactive calling form for an action type is of the same form
as that of a regular Emacs Lisp function definition (see the
documentation for the Emacs Lisp `(interactive)' form).  It may
additionally use Hyperbole command character extensions when the form
is given as a string.  Each such extension character _must_ be preceded
by a plus sign, `+', in order to be recognized since such characters
may also have standard interactive form meanings.

   The present Hyperbole extension characters are:

*+I*
     Prompts for an existing Info node name and file.

*+K*
     Prompts for an existing kcell identifier, either a full outline
     level identifier or a permanent idstamp.

*+M*
     Prompts for a mail message date and the file name it resides in.
     The mail parameters prompted for by this character code are likely
     to change in the future.

*+V*
     Prompts for a Hyperbole view specification.  Not yet available for
     use.


   Arguments are read by the functions in Hyperbole's `hargs' class,
rather than the standard Lisp `read' functions, in order to allow
direct selection of arguments via the Action Key.

   If an action type create is successful, the symbol that Hyperbole
uses internally to reference the type is returned.  `Nil' is returned on
failure so that you may test whether or not the operation succeeds.

   Once you have defined an action type within your present Hyperbole
environment, you can create new explicit buttons which use it.  There is
no explicit button type beyond its action type, so no further work is
necessary.

   Call `(actype:delete)' to remove an action type from a Hyperbole
environment.  It takes a single parameter which should be the same type
symbol used in the type definition call (not the Hyperbole symbol
returned by the call).


File: hyperbole.info,  Node: Implicit Button Types,  Prev: Action Type Creation,  Up: Creating Types

10.2.2 Implicit Button Types
----------------------------

An implicit button type is created or loaded via the `(defib)' function
(which is an alias for `(ibtype:create)').  The calling signature for
this function is given in its documentation; it is the same as that of
`(defun)', but with a number of constraints.  The parameter list should
always be empty since no parameters will be used.  A documentation
string is required.  The type's body follows this.

   The body of an implicit button type is a predicate which determines
whether or not point is within an implicit button of the type.  If not,
the predicate returns `nil'.  If so, it may optionally setup to flash
the button and then perform one or more actions.  A call of the form:
`(ibut:label-set label start-pos end-pos)' is used to setup the button
flashing, if desired.  This is then typically immediately followed by
an action invocation of the form: `(hact 'actype &rest
actype-arguments)'.  It is imperative that all actions (non-predicate
code) be invoked through the `(hact)' function rather than directly or
your ibtypes will not work properly.  (Hyperbole first tests to see if
any ibtype matches the current context before activating any type, so
it ensures that `(hact)' calls are disabled during this testing.)  Any
action types used may be created before or after the implicit button
type definition but obviously should be defined before any implicit
buttons of the given type are activated; an error will result,
otherwise.

   If an implicit button type create is successful, the symbol that
Hyperbole uses internally to reference the type is returned.  `Nil' is
returned on failure so that you may test whether or not the operation
succeeds.  Implicit button type names and action type names may be the
same without any conflict.  In fact, such naming is encouraged when an
implicit button type is the exclusive user of an action type.

   Call `(ibtype:delete)' to remove an implicit button type from a
Hyperbole environment.  It takes a single parameter which should be the
same type symbol used in the type definition call (not the Hyperbole
symbol returned by the call).  This will not delete the action type used
by the implicit button; that must be done separately.

   By default, a request for help on an implicit button will display the
button's attributes in the same manner as is done for explicit buttons.
For some implicit button types, other forms of help will be more
appropriate.  If an Emacs Lisp function is defined whose name is formed
from the concatenation of the type name followed by `:help', e.g.
`my-ibtype:help', it is used to respond to requests for help on buttons
of that type.  Any such function should take a single argument of an
implicit button construct.  (This is what `(ibut:at-p)' returns when
point is within an implicit button context.)  The button may be queried
for its attributes using functions from the `hbut' and `hattr' classes.
See the `hib-kbd.el' file for an example of a custom help function.


File: hyperbole.info,  Node: Explicit Button Technicalities,  Next: Encapsulating Systems,  Prev: Creating Types,  Up: Developing with Hyperbole

10.3 Explicit Button Technicalities
===================================

* Menu:

* Button Label Normalization::
* Operational and Storage Formats::
* Programmatic Button Creation::


File: hyperbole.info,  Node: Button Label Normalization,  Next: Operational and Storage Formats,  Prev: Explicit Button Technicalities,  Up: Explicit Button Technicalities

10.3.1 Button Label Normalization
---------------------------------

Hyperbole uses a normalized form of button labels called button keys (or
label keys) for all internal operations.  See the documentation for the
function `(hbut:label-to-key)' for details of the normalization
process.  The normalized form permits Hyperbole to recognize buttons
that are the same but whose labels appear different from one another,
due to text formatting conventions.  For example, all of the following
would be recognized as the same button.

       <(fake button)>     <( fake      button)>

       Pam>  <(fake
       Pam>    button)>

       ;; <(fake
       ;;   button)>

       /* <( fake      */
       /*    button )> */

   The last three examples demonstrate how Hyperbole ignores common fill
prefix patterns that happen to fall within the middle of a button label
that spans multiple lines.  As long as such buttons are selected with
point at a location within the label's first line, the button will be
recognized.  The variable HBUT:FILL-PREFIX-REGEXPS holds the list of
fill prefixes recognized when embedded within button labels.  All such
prefixes are recognized (one per button label), regardless of the
setting of the GNU Emacs variable, FILL-PREFIX, so no user intervention
is required.


File: hyperbole.info,  Node: Operational and Storage Formats,  Next: Programmatic Button Creation,  Prev: Button Label Normalization,  Up: Explicit Button Technicalities

10.3.2 Operational and Storage Formats
--------------------------------------

Hyperbole uses a terse format to store explicit buttons and a more
meaningful one to show users and to manipulate during editing.  The
terse format consists solely of button attribute values whereas the edit
format includes an attribute name with each attribute value.  A button
in edit format consists of a Lisp symbol together with its attribute
list which holds the attribute names and values.  In this way, buttons
may be passed along from function to function simply by passing the
symbol to which the button is attached.  Most functions utilize the
pre-defined HBUT:CURRENT symbol by default to store and retrieve the
last encountered button in edit format.

   The `hbdata' class handles the terse, stored format.  The `hbut',
`ebut', and `ibut' classes work with the name/value format.  This
separation permits the wholesale replacement of the storage manager
with another, with any interface changes hidden from any Hyperbole
client programming.


File: hyperbole.info,  Node: Programmatic Button Creation,  Prev: Operational and Storage Formats,  Up: Explicit Button Technicalities

10.3.3 Programmatic Button Creation
-----------------------------------

A common need when developing with Hyperbole is the ability to create or
modify explicit buttons without user interaction.  For example, an
application might require the addition of an explicit summary button to
a file for each new mail message a user reads that contains a set of
keywords.  The user could then check the summary file and jump to
desired messages quickly.

   The Hyperbole class `ebut' supports programmatic access to explicit
buttons.  See it within the `hbut.el' file for full details.  The
documentation for `(ebut:create)' explains the set of attributes
settings necessary to create an explicit button.  For operations over
the whole set of buttons within the visible (non-narrowed) portion of a
buffer, use the `(ebut:map)' function.


File: hyperbole.info,  Node: Encapsulating Systems,  Next: Embedding Hyperbole,  Prev: Explicit Button Technicalities,  Up: Developing with Hyperbole

10.4 Encapsulating Systems
==========================

A powerful use of implicit button types is to provide a Hyperbole-based
interface to external systems.  The basic idea is to interpret patterns
output by the application as implicit buttons.

   See the `hsys-*' files for examples of how to do this.
Encapsulations are provided for the following systems (the systems
themselves are not included with Hyperbole):

*World-Wide Web
     The world-wide web system originally developed at CERN, that now
     spans the Internet universe.  This is automatically loaded by
     Hyperbole so that a press of the Action Key follows a URL.

*WAIS
     The Wide Area Information Systems full text-retrieval system
     orginally developed at Thinking Machines and then later at WAIS
     Inc.

*HyperBase
     A hypertextual storage manager that stores textual nodes as
     records with locking so that multiple users can read and edit
     hypertexts.


File: hyperbole.info,  Node: Embedding Hyperbole,  Prev: Encapsulating Systems,  Up: Developing with Hyperbole

10.5 Embedding Hyperbole
========================

[NOTE: We have never done this ourselves, though we have done similar
things which leads us to infer that the task should not be difficult.]

   The standard Emacs-based Hyperbole user interface has purposely been
separated from the Hyperbole backend to support the development of
alternative interfaces and the embedding of Hyperbole functionality
within other system prototypes.  The Hyperbole backend functionality
that system developers can make use of is called its Application
Programming Interface (API).  The API may be used to make server-based
calls to Hyperbole when Emacs is run as a non-interactive (batch)
process, with its input/output streams attached to another process.

   The public functions and variables from the following files may be
considered the present Hyperbole API:

`hact.el', `hargs.el', `hbmap.el', `hbut.el', `hhist.el', `hmail.el',
`hmoccur.el', `hpath.el', `htz.el', `hypb.el', `set.el', `wconfig.el',
`wrolo.el', and `wrolo-logic.el'.

Note when looking at these files, that they are divided into sections
that separate one data abstraction (class) from another.  A line of
dashes within a class separates public parts of the class from the
private parts that follow the line.

   This API does not include the Hyperbole outliner, as it has been
designed for interactive use, rather than programmatic extensibility.
You can certainly study its code, below the `hyperbole/kotl/' directory
and learn to program it, however.


File: hyperbole.info,  Node: Glossary,  Next: Smart Key Reference,  Prev: Developing with Hyperbole,  Up: Top

Appendix A Glossary
*******************

Concepts pertinent to operational usage of Hyperbole are defined here.
If some GNU Emacs terms are unfamiliar to you, *Note Emacs Glossary:
(emacs)Glossary.

`action'
     An executable behavior associated with a Hyperbole button.  A
     specific class of actions which display entities are called
     _links_, such as a link to a file.

`Action Key'
     See _Smart Key_.

`action type'
     A behavioral specification for use within Hyperbole buttons.
     Action types usually contain a set of parameters which must be
     given values for each button with which they are associated.  An
     action type together with a set of values, called arguments, may
     be considered an _action_.  _Actype_ is a synonym for action type.

`activation'
     Request for a Hyperbole button to perform its action.  Ordinarily
     the user presses a key which selects and activates a button.

`ange-ftp'
     A standard GNU Emacs Lisp package which allows one to use pathnames
     that are accessible via the Internet File Transfer Protocol (ftp)
     just like other pathnames, for example when finding a file.  The
     latest version of ange-ftp may always be obtained via anonymous
     ftp to: `/ftp.gnu.ai.mit.edu:ange-ftp/ange-ftp.tar.gz'.

`argument'
     A button-specific value fed to a Hyperbole type specification when
     the button is activated.

`Assist Key'
     See _Smart Key_.

`attributes'
     Slot names associated with Hyperbole buttons.  An _attribute value_
     is associated with each button attribute.

`Augment'
     The Augment system, originally named NLS, was a pioneering
     research and production system aimed at augmenting human intellect
     and group knowledge processing capabilities through integrated
     tools and organizational development strategies.  This approach
     led to the invention of much of interactive computing technology
     decades ahead of other efforts, including: the mouse, screen
     windows, true hypertext, outline processors, groupware, and
     digitally signed documents.  *Note References::, which cites
     several Douglas Engelbart papers on the subject.  The Koutliner
     concept emerged from studies of publicly available information
     concerning Augment.

`button'
     A selectable Hyperbole construct which performs an action.  A
     button consists of a set of attributes that includes: a textual
     label, a category, a type and zero or more arguments.  _Explicit
     buttons_ also have creator, create time, last modifier, and last
     modifier time attributes.

     Buttons provide the user's gateway to information.  The user sees
     and interacts with button labels, the rest of the button data is
     managed invisibly by Hyperbole and displayed only in response to
     user queries.

`button activation'
     See _activation_.

`button attributes'
     See _attributes_.

`button data'
     Lists of button attribute values explicitly saved and managed by
     Hyperbole.  One list for each button created by Hyperbole.

`button file, local'
     A per-directory file named `HYPB' that may be used to store any
     desired buttons and may then be displayed via a menu selection
     whenever a user is within that directory.

`button file, personal'
     A per-user file named `HYPB' that may be used to store any desired
     buttons and may then be displayed via a menu selection.

`button key'
     A normalized form of a _button label_ used internally by Hyperbole.

`button label'
     A text string that visually indicates a Hyperbole button location
     and provides it with a name and unique identifier.  Within a
     buffer, buttons with the same label are considered separate views
     of the same button and so behave exactly alike.  Since button
     labels are simply text strings, they may be embedded within any
     text to provide non-linear information or operational access
     points.

     The maximum length of a button label is limited by the variable
     EBUT:MAX-LEN.

`button selection'
     The act of designating a Hyperbole button upon which to operate.
     Use the Action Key to select a button.

`category'
     A high-level, conceptual grouping of Hyperbole buttons into
     classes.  _Implicit_ and _explicit_ groupings represent categories.

`cell'
     See _kcell_.

`children'
     The set of koutline cells which share a common parent cell and are
     one level deeper than the parent.

`class'
     A group of functions and variables with the same prefix in their
     names, used to provide an interface to an internal or external
     Hyperbole abstraction.

`context'
     A programmatic or positional state recognized by Hyperbole.  We
     speak of Smart Key and implicit button contexts.  Both are
     typically defined in terms of surrounding patterns within a
     buffer, but may be defined by arbitrary Emacs Lisp predicates.
     (Context may come to have a broader meaning within future versions
     of Hyperbole.)

`environment'
     See _Hyperbole environment_.

`efs'
     The much larger successor to ange-ftp.  It does the same thing as
     ange-ftp but works with more types of ftp hosts.  See _ange-ftp_.

`explicit button'
     A button created and managed by Hyperbole.  By default, explicit
     buttons are delimited like this `<(fake button)>'.  Direct
     selection is used to operate upon an explicit button.

`global button'
     A form of explicit button which is typically accessed by name
     rather than direct selection.  Global buttons are useful when one
     wants quick access to actions such as jumping to common file
     locations or for performing sequences of operations.  One need not
     locate them since they are always available by name, with full
     completion offered.  All global buttons are stored in the file
     given by the variable GBUT:FILE and may be activated as regular
     explicit buttons by visiting this file.  By default, this is the
     same as the user's personal button file.

`global button file'
     See _button file, personal_.

`hook variable'
     A variable that permits customization of an existing function's
     operation without the need to edit the function's code.  See also
     the documentation for the function `(run-hooks)'.

`Hyperbole'
     A flexible, programmable information management and viewing system
     built on top of GNU Emacs.  It utilizes a button-action model and
     supports hypertextual linkages.  Hyperbole is all things to all
     people.

`Hyperbole environment'
     A programmatic context within which Hyperbole operates.  This
     includes the set of Hyperbole types defined and the set of
     Hyperbole code modules loaded.  It does not include the set of
     accessible buttons.  Although the entire Emacs environment is
     available to Hyperbole, we do not speak of this as part of the
     Hyperbole environment.

`hypertext'
     A text or group of texts which may be explored in a non-linear
     fashion through associative linkages embedded throughout the text.
     Instead of simply referring to other pieces of work, hypertext
     references when followed actually take you to the works themselves.

`implicit button'
     A button recognized contextually by Hyperbole.  Such buttons
     contain no button data.  See also _implicit button type_.

`implicit button type'
     A specification of how to recognize and activate implicit buttons
     of a specific kind.  Implicit button types often utilize structure
     internal to documents created and managed without Hyperbole
     assistance, for example, programming documentation.  _Ibtype_ is a
     synonym for implicit button type.  See also _system encapsulation_.

`instance number'
     A colon prefaced number appended to the label of a newly created
     button when the button's label duplicates the label of an existing
     button in the current buffer.  This number makes the label unique
     and so allows any number of buttons with the same base label
     within a single buffer.

`koutline'
     A hierarchically ordered grouping of cells which may be stored as
     a file and viewed and edited as an outline.

`Koutliner'
     Koutliner, the Hyperbole outliner, is a powerful autonumbering
     outliner with permanent hypertext anchors for easy hyperlinking
     and view specs for rapid outline view alteration.

`kcell'
     Cells or kcells are elements within koutlines.  Each cell contains
     textual and graphical contents, a relative identifier, a permanent
     identifier and a set of attributes such as the user who created
     the cell and the time of creation.  See also _Koutliner_.

`link'
     A reference from a Hyperbole button to an entity.  The referenced
     entity is sometimes called a _node_ or _referent_.  A specific
     class of actions which display entities are called _links_, such
     as a link to a file.

`local button file'
     See _button file, local_.

`minibuffer window'
     The one line window at the bottom of a frame where messages and
     prompts are displayed.

`minibuffer menu'
     A Hyperbole menu displayed in the minibuffer window.  Each menu
     item within a minibuffer menu begins with a different letter that
     can be used to invoke the item (case doesn't matter).  Items that
     display other menus end with a forward slash, /.

`mouse button'

`mouse key'
     See _Smart Key_.

`node'
     See _link_ or _cell_.

`outline'
     See _koutline_.

`parent'
     Any koutline cell which has children.

`predecessor'
     The previous same level koutline cell with the same parent.

`predicate'
     A boolean (nil = false, non-nil = true) Lisp expression typically
     evaluated as part of a conditional expression.

`referent'
     See _link_.

`rolodex'
     Wrolo, the Hyperbole rolodex, provides rapid lookup of multi-line,
     hierarchically ordered free form text records.

`root cell'
     A koutline cell which has cells below it.  All such cells share
     the same root cell.

`Smart Key'
     A context-sensitive key used within Hyperbole and beyond.
     Actually, there are two Smart Keys, the Action Key and the Assist
     Key.  The Action Key, typically bound to the shift-middle mouse
     key (or shift-left mouse key on a 2-button mouse), activates
     Hyperbole buttons and scrolls the current buffer line to the top
     of the window when pressed at the end of a line.  The Assist Key,
     typically bound to the shift-right mouse key, explains what a
     Hyperbole button does or scrolls the current line to the bottom of
     the window when pressed at the end of a line.  (See the
     documentation for the variable, SMART-SCROLL-PROPORTIONAL, for
     information on how to make these keys scroll forward and backward a
     windowful at a time).

     To see what a Smart Key will do within a particular context,
     depress and hold the key at the point desired and depress the
     other Smart Key.  A buffer containing a description of its
     contextual function will then be displayed.  You may release the
     two keys in any order after you have them both depressed.  A press
     of the Assist Key in an unsupported context displays a summary of
     Smart Key functions in each context, as does the Doc/SmartKy menu
     item.

`source buffer / file'
     The buffer or file within which a Hyperbole button is embedded.

`subtree'
     All of the cells in a koutline which share the same root cell,
     excluding the root cell.

`successor'
     The next same level koutline cell with the same parent.

`system encapsulation'
     Use of Hyperbole to provide an improved or simply consistent user
     interface to another system.  Typically, implicit button types are
     defined to recognize and activate button-type constructs managed
     by the other system.

`tree'
     The set of cells in a koutline that share a common root cell,
     including the root cell.

`view'
     A perspective on some information.  A view can affect the extent
     of the information displayed, its format, modes used to operate on
     it, its display location and so forth.

`view spec'
     A terse (and to the uninitiated, cryptic) string that specifies a
     particular view of koutline or a link referent.  If a view spec is
     in use in a buffer, the view spec appears in the modeline
     delimited by <|view spec>.



File: hyperbole.info,  Node: Smart Key Reference,  Next: Outliner Keys,  Prev: Glossary,  Up: Top

Appendix B Smart Key Reference
******************************

This appendix supplies complete documentation on Smart Key operation.
It is quite extensive and is meant for reference rather than sequential
reading.  *Note Smart Keys::, for a description of the Smart Keys.
That section also describes how to get context-sensitive Smart Key
help, with which you can explore Smart Key operation bit by bit.

   Smart Key operations are context-sensitive.  Contexts are described
herein as conditionals, e.g. when depressed here, if this is true, etc.
Each Smart Key context is listed in the order in which it will be
checked.  The first matching context is always the one applied.  Within
each context, the actions performed by the Action and Assist Keys are
listed.

* Menu:

* Smart Mouse Keys::
* Smart Keyboard Keys::


File: hyperbole.info,  Node: Smart Mouse Keys,  Next: Smart Keyboard Keys,  Prev: Smart Key Reference,  Up: Smart Key Reference

B.1 Smart Mouse Keys
====================

Smart Key drags and modeline presses can only be used when running under
a window system with mouse key support.  So keep in mind that the
operations in this section apply only if you have mouse support within
Hyperbole.  The Smart Key operations in, *Note Smart Keyboard Keys::,
apply to both mouse and keyboard Smart Key usage.

If dragged from a side-by-side window edge or from the immediate left of
a vertical scroll bar:
  ACTION or ASSIST
     Resizes adjacent window sides to the point of drag release.

If dragged from inside one window to another:
  ACTION
     Creates a new link button at the drag start location, linked to the
     drag end location.  If drag start position is within a button,
     modifies the button to link to drag end location.
  ASSIST
     Swaps buffers in the two windows.

If dragged horizontally within a single window while depressed
(hmouse-x-drag-sensitivity sets the minimal horizontal movement which
registers a drag):
  ACTION
     Goes to buffer end if drag was to the right, otherwise goes to beginning.
  ASSIST
     Splits window vertically if drag was to the right, otherwise deletes
     window.

If depressed within a window mode line:
  ACTION
     (1) clicked on left edge of a window's modeline,
         window's buffer is buried (placed at bottom of buffer list);
     (2) clicked on right edge of a window's modeline,
         the Info buffer is displayed, or if already displayed and the
         modeline clicked belongs to a window displaying Info, the Info
         buffer is hidden;
     (3) clicked anywhere in the middle of a window's modeline,
	 the functions listed in 'assist-key-modeline-hook' are
         called;
     (4) dragged vertically from modeline to within a window,
         the modeline is moved to point of key release, thereby resizing
         its window and potentially its vertical neighbors.
  ASSIST
     (1) clicked on left edge of a window's modeline,
         bottom buffer in buffer list is unburied and placed in window;
     (2) clicked on right edge of a window's modeline,
         the summary of Smart Key behavior is displayed, or if already
         displayed and the modeline clicked belongs to a window displaying
         the summary, the summary buffer is hidden;
     (3) clicked anywhere in the middle of a window's modeline,
         a popup menu (if available) is displayed;
     (4) dragged vertically from modeline to within a window,
         the modeline is moved to point of key release, thereby resizing
         its window and potentially its vertical neighbors.

If dragged vertically within a single window while depressed
(hmouse-y-drag-sensitivity sets the minimal vertical movement which
registers a drag):
  ACTION or ASSIST
     Splits current window into two side-by-side windows.

If dragged diagonally within a single window while depressed
(hmouse-x-diagonal-sensitivity and hmouse-y-diagonal-sensitivity set the
minimal diagonal movement which registers a drag):
  ACTION
     Save current window configuration onto a ring of window configurations.
  ASSIST
     Restores prior window configuration from ring.  A prefix argument N
     specifies the Nth prior configuration from the ring.


File: hyperbole.info,  Node: Smart Keyboard Keys,  Prev: Smart Mouse Keys,  Up: Smart Key Reference

B.2 Smart Keyboard Keys
=======================

When prompting for a Hyperbole argument, a press in the minibuffer:
  ACTION
     Terminates this minibuffer argument.
  ASSIST
     Offers completion help for current minibuffer argument.

When reading a Hyperbole menu item or a Hyperbole completion-based argument:
  ACTION
     Returns value selected at point if any, else nil.  If
     value is the same as the contents of the minibuffer, it is used as the
     current minibuffer argument, otherwise, the minibuffer is erased and
     value is inserted there.

  ASSIST
     Displays Hyperbole menu item help when item is selected.

When pressed at the end of a line but not the end of a buffer:
  ACTION
     Scrolls up according to value of smart-scroll-proportional.  If
     smart-scroll-proportional is nil or if point is on the top
     window line, scrolls up (forward) a windowful.  Otherwise, tries to
     bring current line to top of window.  Leaves point at end of line and
     returns t if scrolled, nil if not.
  ASSIST
     Scrolls down according to value of smart-scroll-proportional.  If
     smart-scroll-proportional is nil or if point is on the
     bottom window line, scrolls down (backward) a windowful.  Otherwise,
     tries to bring current line to bottom of window.  Leaves point at end of
     line and returns t if scrolled, nil if not.

When pressed on a Hyperbole button:
  ACTION
     Activates button.
  ASSIST
     Displays help for button, typically a summary of its attributes.

If pressed within a buffer in View major or minor mode:
  ACTION
     Scrolls buffer forward a windowful and quits from view mode when at
     the last line of the buffer.
  ASSIST
     Scrolls buffer backward a windowful.

When pressed within a Hyperbole outliner buffer (kotl-mode):
  ACTION
     (1) at the end of buffer, uncollapse and unhide all cells in view;
     (2) within a cell, if its subtree is hidden then show it,
         otherwise hide it;
     (3) between cells or within the read-only indentation region to the
         left of a cell, then move point to prior location and begin
	 creation of a klink to some other outline cell; hit the Action
	 Key twice to select the link referent cell;
     (4) anywhere else, scroll up a windowful.
  ASSIST
     (1) at the end of buffer, collapse all cells and hide all non-level-one
         cells;
     (2) on a header line but not at the beginning or end, display
         properties of each cell in kotl beginning at point;
     (3) between cells or within the read-only indentation region to the
         left of a cell, then move point to prior location and prompt to
         move one tree to a new location in the outline; hit the Action
         Key twice to select the tree to move and where to move it;
     (4) anywhere else, scroll down a windowful.

When pressed on a Smart Menu item:
  ACTION
    Activates item.
  ASSIST
    Displays help for item.

When pressed at the end of a Help buffer:
  ACTION or ASSIST
    Restores window configuration prior to help display.

When pressed within an OO-Browser listing window:
  ACTION
     (1) in a blank buffer or at the end of a buffer, browser help
         information is displayed in the viewer window;
     (2) at the beginning of a (non-single char) class name, the class'
         ancestors are listed;
     (3) at the end of an entry line, scrolls listing up;
     (4) on the '...', following a class name, point is moved to the class
         descendency expansion;
     (5) before an element name, the implementor classes of the name are
         listed;
     (6) anywhere else on an entry line, the source is displayed for editing.
  ASSIST
     (1) in a blank buffer, a selection list of buffer files is displayed;
     (2) at the beginning of a (non-single char) entry, the class'
         descendants are listed;
     (3) at the end of an entry line, scrolls listing down;
     (4) on the '...', following a class name, point is moved to the class
         expansion;
     (5) anywhere else on a class entry line, lists the class' elements;
     (6) anywhere else on an element line, lists the element's implementor
         classes;
     (7) on a blank line following all entries, the current listing buffer
         is exited.

When pressed within an OO-Browser Command Help Menu buffer:
  ACTION
     Executes an OO-Browser command whose key binding is at point.
  ASSIST
     Displays help for an OO-Browser command whose key binding is at point.

When pressed on an identifier within an OO-Browser source file:
  ACTION
     Tries to display identifier definition.
  ASSIST
     Not applicable.

When pressed within a C source code file:
  ACTION
     Jumps to the definition of selected C construct:
     (1) on a '#include' statement, the include file is displayed;
         Look for include file in directory lists
         'smart-c-cpp-include-dirs' and 'smart-c-include-dirs'.
     (2) on a C identifier, the identifier definition is displayed,
         assuming the identifier is found within an 'etags' generated tag file
         in the current directory or any of its ancestor directories.
     (3) if 'smart-c-use-lib-man' is non-nil, the C identifier is
         recognized as a library symbol, and a man page is found for the
         identifier, then the man page is displayed.
  ASSIST
     Jumps to the next tag matching an identifier at point.

When pressed within an assembly source code file:
  ACTION
     Jumps to the definition of selected assembly construct:
     (1) on an include statement, the include file is displayed;
         Look for include file in directory list
         'smart-asm-include-dirs'.
     (2) on an identifier, the identifier definition is displayed,
         assuming the identifier is found within an 'etags' generated
	 tag file in the current directory or any of its ancestor
	 directories.
  ASSIST
     Jumps to the next tag matching an identifier at point.

When pressed within a C++ source code file:
  ACTION
     Jumps to the definition of selected C+ construct:
     (1) on a '#include' statement, the include file is displayed;
         Look for include file in directory lists
         'smart-c-cpp-include-dirs' and 'smart-c-include-dirs'.
     (2) on a C++ identifier, the identifier definition is displayed,
         assuming the identifier is found within an 'etags' generated tag file
         in the current directory or any of its ancestor directories.
     (3) if 'smart-c-use-lib-man' is non-nil, the C++ identifier is
         recognized as a library symbol, and a man page is found for the
         identifier, then the man page is displayed.
  ASSIST
     Jumps to the next tag matching an identifier at point.

When pressed within a Objective-C source code file:
  ACTION
     Jumps to the definition of selected C+ construct:
     (1) on a '#include' statement, the include file is displayed;
         Look for include file in directory lists
         'smart-c-cpp-include-dirs' and 'smart-c-include-dirs'.
     (2) on an Objective-C identifier, the identifier definition is displayed,
         assuming the identifier is found within an 'etags' generated tag file
         in the current directory or any of its ancestor directories.
     (3) if 'smart-c-use-lib-man' is non-nil, the Objective-C identifier is
         recognized as a library symbol, and a man page is found for the
         identifier, then the man page is displayed.
  ASSIST
     Jumps to the next tag matching an identifier at point.

When pressed on a Lisp symbol within a Lisp code buffer:
  ACTION
     Jumps to the definition of any selected Lisp construct.
     If on an Emacs Lisp require, load, or autoload clause and 'find-library'
     from load-library package by Hallvard Furuseth <hallvard@ifi.uio.no> has
     been loaded, jumps to library source, if possible.
  ASSIST
     Jumps to the next tag matching an identifier at point or if using the
     "wtags" package and identifier is an Emacs Lisp symbol, then displays
     documentation for the symbol.

When the OO-Browser has been loaded and the press is within a C++ buffer:
  ACTION or ASSIST
     Jumps to the definition of selected C++ construct via OO-Browser support.
     (1) on a '#include' statement, the include file is displayed;
         Look for include file in directory lists
         'smart-c-cpp-include-dirs' and 'smart-c-include-dirs'.
     (2) within a method declaration, its definition is displayed;
     (3) on a class name, the class definition is shown.

When the OO-Browser has been loaded and the press is within a
Objective-C buffer:
  ACTION or ASSIST
     Jumps to the definition of selected Objective-C construct via
     OO-Browser support.
     (1) on a '#include' statement, the include file is displayed;
         Look for include file in directory lists
         'smart-c-cpp-include-dirs' and 'smart-c-include-dirs'.
     (2) within a method declaration, its definition is displayed;
     (3) on a class name, the class definition is shown.

When pressed within an occur-mode or moccur-mode buffer:
  ACTION or ASSIST
     Jumps to the source buffer and line of the current occurrence.

When pressed within a calendar-mode buffer:
  ACTION
     (1) at the end of the buffer, the calendar is scrolled forward 3 months;
     (2) to the left of any dates on a calendar line, the calendar is scrolled
         backward 3 months;
     (3) on a date, the diary entries for the date, if any, are displayed.
  ASSIST
     (1) at the end of the buffer, the calendar is scrolled backward 3 months;
     (2) to the left of any dates on a calendar line, the calendar is scrolled
         forward 3 months;
     (3) anywhere else, all dates with marking diary entries are marked in the
         calendar window.

When pressed within a man page apropos buffer:
  ACTION
     (1) on a UNIX man apropos entry, the man page for that entry is
         displayed in another window;
     (2) on or after the last line, the buffer in the other window is
         scrolled up a windowful.
  ASSIST
     (1) on a UNIX man apropos entry, the man page for that entry is
         displayed in another window;
     (2) on or after the last line, the buffer in the other window is
         scrolled down a windowful.

If Smart Menu package has been loaded and 'hkey-always-display-menu' is
non-nil:
  ACTION or ASSIST
     Pops up a window with a Smart Menu of commands.
     Menu displayed is selected by (smart-menu-choose-menu).

If pressed within an outline-mode buffer or when 'selective-display' is
non-nil:
  ACTION
     Collapses, expands, and moves outline entries.
     (1) after an outline heading has been cut via the Action Key, then paste
         the cut heading at point;
     (2) at the end of buffer, show all buffer text
     (3) at the beginning of a heading line, cut the headings subtree from the
         buffer;
     (4) on a header line but not at the beginning or end, if headings
         subtree is hidden then show it, otherwise hide it;
     (5) anywhere else, scroll up a windowful.
  ASSIST
     (1) after an outline heading has been cut via the Action Key, allow
         multiple pastes throughout the buffer (last paste should be done
         with the Action Key, not the Assist Key);
     (2) at the end of buffer, hide all bodies in buffer;
     (3) at the beginning of a heading line, cut the current heading (sans
         subtree) from the buffer;
     (4) on a header line but not at the beginning or end, if heading body is
         hidden then show it, otherwise hide it;
     (5) anywhere else, scroll down a windowful.

If pressed within an Info manual node:
  ACTION
     (1) the first line of an Info Menu Entry or Cross Reference, the desired
         node is found;
     (2) the Up,Next,or Previous entries of a Node Header (first line),
         the desired node is found;
     (3) the File entry of a Node Header (first line),
         the 'Top' node within that file is found;
     (4) at the end of the current node, the Next node is found (this will
         descend subtrees if the function 'Info-global-next' is bound);
     (5) anywhere else (e.g. at the end of a line), the current node entry is
         scrolled up a windowful.
  ASSIST
     (1) the first line of an Info Menu Entry or Cross Reference, the desired
         node is found;
     (2) the Up,Next,or Previous entries of a Node Header (first line),
         the last node in the history list is found;
     (3) the File entry of a Node Header (first line),
         the 'DIR' root-level node is found;
     (4) at the end of the current node, the Previous node is found (this will
         return from subtrees if the function 'Info-global-prev is bound);
     (5) anywhere else (e.g. at the end of a line), the current node entry is
         scrolled down a windowful.

If pressed within a Hyperbole-supported mail reader, 'hmail:reader', or mail
summary mode, 'hmail:lister', buffer at:
  ACTION
     (1) a msg buffer, within the first line or at the end of a message,
         the next undeleted message is displayed;
     (2) a msg buffer within the first line of an Info cross reference, the
         reference is followed;
     (3) anywhere else in a msg buffer, the window is scrolled up one
	 windowful;
     (4) a msg summary buffer on a header entry, the message corresponding to
         the header is displayed in the msg window;
     (5) a msg summary buffer, on or after the last line, the messages marked
         for deletion are expunged.
  ASSIST
     (1) a msg buffer, within the first line or at the end of a message,
         the previous undeleted message is displayed;
     (2) a msg buffer within the first line of an Info cross reference, the
         reference is followed;
     (3) anywhere else in a msg buffer, the window is scrolled down one
         windowful;
     (4) a msg summary buffer on a header entry, the message corresponding to
         the header is marked as deleted;
     (5) a msg summary buffer, on or after the last line, all messages are
         marked undeleted.

If pressed within a GNUS listing of newsgroups buffer at:
  ACTION
     (1) a GNUS-GROUP line, that newsgroup is read;
     (2) to the left of any GNUS-GROUP line, on any of the whitespace, the
         current group is unsubscribed or resubscribed;
     (3) at the end of the GNUS-GROUP buffer, after all lines, checks for new
         news.
  ASSIST
     (1) a GNUS-GROUP line, that newsgroup is read;
     (2) to the left of any GNUS-GROUP line, on any of the whitespace, the
         user is prompted for a group name to subscribe or unsubscribe to;
     (3) at the end of the GNUS-GROUP buffer, after all lines, quits from the
         newsreader.

If pressed within a GNUS newsreader subject listing buffer at:
  ACTION
     (1) a GNUS-SUBJECT line, that article is read, marked deleted, and
         scrolled forward;
     (2) at the end of the GNUS-SUBJECT buffer, the next undeleted article
         is read or the next group is entered.
  ASSIST
     (1) a GNUS-SUBJECT line, that article is read and scrolled backward;
     (2) at the end of the GNUS-SUBJECT buffer, the subject is exited, the
         user is returned to group mode.

If pressed within a GNUS newsreader article buffer at:
  ACTION
     (1) the first line or end of an article, the next unread message is
         displayed;
     (2) the first line of an Info cross reference, the reference is followed;
     (3) anywhere else, the window is scrolled up a windowful.
  ASSIST
     (1) the first line or end of an article, the previous message is
         displayed;
     (2) the first line of an Info cross reference, the reference is followed;
     (3) anywhere else, the window is scrolled down a windowful.

If pressed within a listing of buffers (Buffer-menu-mode):
  ACTION
     (1) on the first column of an entry, the selected buffer is marked for
         display;
     (2) on the second column of an entry, the selected buffer is marked to be
         saved;
     (3) anywhere else within an entry line, all saves and deletes are done,
         and selected buffers are displayed, including the one just clicked
         on (if in the OO-Browser, only the selected buffer is displayed);
     (4) on or after the last line in the buffer, all saves and deletes are
         done.
  ASSIST
     (1) on the first or second column of an entry, the selected buffer is
         unmarked for display and for saving or deletion;
     (2) anywhere else within an entry line, the selected buffer is marked for
         deletion;
     (3) on or after the last line in the buffer, all display, save, and delete
         marks on all entries are undone.

If pressed within a dired-mode buffer:
  ACTION
     (1) within an entry line, the selected file/directory is displayed
         for editing in the other window;
     (2) on or after the last line in the buffer, if any deletes are to be
         performed, they are executed after user verification, otherwise, this
         dired invocation is quit.
  ASSIST
     (1) on a '~' character, all backup files in the directory are marked for
         deletion;
     (2) on a '#' character, all auto-save files in the directory are marked
         for deletion;
     (3) anywhere else within an entry line, the current entry is marked for
         deletion;
     (4) on or after the last line in the buffer, all delete marks on all
         entries are undone.

If pressed within a tar-mode buffer:
  ACTION
     (1) within an entry line, the selected file/directory is displayed
         for editing in the other window;
     (2) on or after the last line in the buffer, if any deletes are to be
         performed, they are executed after user verification, otherwise, this
         tar file browser is quit.
  ASSIST
     (1) on an entry line, the current entry is marked for deletion;
     (2) on or after the last line in the buffer, all delete marks on all
         entries are undone.

If pressed on a cross reference within a man page entry section labeled
NAME, SEE ALSO, or PACKAGES USED, or within a man page C routine
specification (see 'smart-man-c-routine-ref') and man page buffer
has either an attached file or else a MAN-PATH local variable
containing its pathname:
  ACTION or ASSIST
     Displays man page or source code for cross reference.

If pressed on a world-wide web universal resource locator:
  ACTION
     Displays the URL referent at point.
  ASSIST
     Goes back to a previously displayed web page.

If pressed in a Gomoku game buffer.
  ACTION
     Makes a move at the space pointed to.
  ASSIST
     Takes back a prior move made at the space pointed to.

If pressed within an entry in the wrolo match display buffer:
  ACTION or ASSIST
     The entry is edited in the other window.


File: hyperbole.info,  Node: Outliner Keys,  Next: Suggestion or Bug Reporting,  Prev: Smart Key Reference,  Up: Top

Appendix C Outliner Keys
************************

This appendix summarizes the specialized key bindings available when
editing an outline with Hyperbole.  Each key is shown together with its
command binding and the documentation for that command.  Normal emacs
editing keys are modified to account for the structure within outlines.
An outliner command which overloads an Emacs command named _cmd_ would
be named _kotl-mode:cmd_.

`kfile:write  {C-x C-w}'
     Write current outline to FILE.

`klink:create  {C-c l}'
     Insert at point an implicit link to REFERENCE.  REFERENCE should
     be a cell-ref or a string containing "filename, cell-ref".  See
     documentation for `kcell:ref-to-id' for valid cell-ref formats.

`kotl-mode:add-cell  {<LFD>}'
     Add a cell following current cell at optional RELATIVE-LEVEL with
     CONTENTS string.  Optional prefix arg RELATIVE-LEVEL means add as
     sibling if nil or >= 0, as child if equal to universal argument,
     `C-u', and as sibling of current cell's parent, otherwise.  If
     added as sibling of current level, RELATIVE-LEVEL is used as a
     repeat count for the number of cells to add.

     Return last newly added cell.

`kotl-mode:add-child  {C-c a}'
     Add a new cell to current kview as first child of current cell.

`kotl-mode:add-parent  {C-c p}'
     Add a new cell to current kview as sibling of current cell's
     parent.

`kotl-mode:append-cell  {C-c +}'
     Append CONTENTS-CELL to APPEND-TO-CELL.  APPEND-TO-CELL is
     refilled if neither cell has a no-fill property and
     kotl-mode:refill-flag is enabled.

`kotl-mode:back-to-indentation  {M-m}'
     Move point to the first non-read-only non-whitespace character on
     this line.

`kotl-mode:backward-cell  {C-c C-b}'
     Move to prefix ARGth prior cell (same level) within current view.
     Return number of cells left to move.

`kotl-mode:backward-char  {C-b}'
     Move point backward ARG (or 1) characters and return point.

`kotl-mode:backward-kill-word  {M-DEL}'
     Kill up to prefix ARG words preceding point within a single cell.

`kotl-mode:backward-sentence  {M-a}'
     Move point backward ARG (or 1) sentences and return point.

`kotl-mode:backward-word  {M-b}'
     Move point backward ARG (or 1) words and return point.

`kotl-mode:beginning-of-buffer  {M-<}'
     Move point to beginning of buffer and return point.

`kotl-mode:beginning-of-cell  {C-c ,}'
     Move point to beginning of current or ARGth - 1 prior cell and
     return point.

`kotl-mode:beginning-of-line  {C-a}'
     Move point to beginning of current or ARGth - 1 line and return
     point.

`kotl-mode:beginning-of-tree  {C-c ^}'
     Move point to the level 1 root of the current cell's tree.  Leave
     point at the start of the cell.

`kotl-mode:center-line  {M-s}'
     Center the line point is on, within the width specified by
     FILL-COLUMN.  This means adjusting the indentation so that it
     equals the distance between the end of the text and FILL-COLUMN.

`kotl-mode:center-paragraph  {M-S}'
     Center each nonblank line in the paragraph at or after point.  See
     `center-line' for more info.

`kotl-mode:copy-after  {C-c c}'
     Copy tree rooted at FROM-CELL-REF to follow tree rooted at
     TO-CELL-REF.  If prefix arg CHILD-P is non-nil, make FROM-CELL-REF
     the first child of TO-CELL-REF, otherwise make it the sibling
     following TO-CELL-REF.

     Leave point at the start of the root cell of the new tree.

`kotl-mode:copy-before  {C-c C-c}'
     Copy tree rooted at FROM-CELL-REF to precede tree rooted at
     TO-CELL-REF.  If prefix arg PARENT-P is non-nil, make
     FROM-CELL-REF the first child of TO-CELL-REF's parent, otherwise
     make it the preceding sibling of TO-CELL-REF.

     Leave point at the start of the root cell of the new tree.

`kotl-mode:copy-to-buffer  {C-c M-c}'
     Copy outline tree rooted at CELL-REF to a non-koutline BUFFER.
     Use 0 to copy the whole outline buffer.

`kotl-mode:copy-to-register  {C-x x}'
     Copy into REGISTER the region START to END.  With optional prefix
     arg DELETE-FLAG, delete region.

`kotl-mode:delete-backward-char  {DEL}'
     Delete up to the preceding prefix ARG characters.  Return number
     of characters deleted.  Optional KILL-FLAG non-nil means save in
     kill ring instead of deleting.  Does not delete across cell
     boundaries.

`kotl-mode:delete-blank-lines  {C-x C-o}'
     On blank line within a cell, delete all surrounding blank lines,
     leaving just one.  On isolated blank line, delete that one.  On
     nonblank line, delete all blank lines that follow it.

     If nothing but whitespace follows point until the end of a cell,
     delete all whitespace at the end of the cell.

`kotl-mode:delete-char  {C-d}'
     Delete up to prefix ARG characters following point.  Return number
     of characters deleted.  Optional KILL-FLAG non-nil means save in
     kill ring instead of deleting.  Does not delete across cell
     boundaries.

`kotl-mode:delete-indentation  {M-^}'
     Join this line to previous and fix up whitespace at join.  If
     there is a fill prefix, delete it from the beginning of this line.
     With argument, join this line to following line.

`kotl-mode:demote-tree  {TAB}'
     Move current kotl a maximum of prefix ARG levels lower in current
     view.  Each cell is refilled iff its _no-fill_ attribute is nil and
     KOTL-MODE:REFILL-FLAG is non-nil.  With prefix ARG = 0, cells are
     demoted up to one level and kotl-mode:refill-flag is treated as
     true.

`kotl-mode:down-level  {C-c C-d}'
     Move down prefix ARG levels lower within current tree.

`kotl-mode:end-of-buffer  {M->}'
     Move point to end of buffer and return point.

`kotl-mode:end-of-cell  {C-c .}'
     Move point to end of current or ARGth - 1 succeeding cell and
     return point.

`kotl-mode:end-of-line  {C-e}'
     Move point to end of current or ARGth - 1 line and return point.

`kotl-mode:end-of-tree  {C-c $}'
     Move point to the last cell in tree rooted at the current cell.
     Leave point at the start of the cell.

`kotl-mode:exchange-cells  {C-c e}'
     Exchange CELL-REF-1 with CELL-REF-2 in current view.  Don't move
     point.

`kotl-mode:fill-cell  {C-c M-j}'
     Fill current cell within current view if it does not have the
     'no-fill attribute.  With optional JUSTIFY, justify cell as well.
     IGNORE-COLLAPSED-P is used when caller has already expanded cell,
     indicating it is not collapsed.

`kotl-mode:fill-paragraph  {C-x f}'
     Fill current paragraph within cell.  With optional JUSTIFY, justify
     paragraph as well.  Ignore any non-nil no-fill attribute attached
     to the cell.

`kotl-mode:fill-tree  {C-M-j}'
     Refill each cell within the tree whose root is at point.

`kotl-mode:first-sibling  {C-c <}'
     Move point to the first sibling of the present cell.  Leave point
     at the start of the cell or at its present position if it is
     already within the first sibling cell.

`kotl-mode:fkey-backward-char  {left}'
     Move point backward ARG (or 1) characters and return point.

`kotl-mode:fkey-forward-char  {right}'
     Move point forward ARG (or 1) characters and return point.

`kotl-mode:fkey-next-line  {down}'
     Move point to ARGth next line and return point.

`kotl-mode:fkey-previous-line  {up}'
     Move point to ARGth previous line and return point.

`kotl-mode:forward-cell  {C-c C-f}'
     Move to prefix ARGth following cell (same level) within current
     view.  Return number of cells left to move.

`kotl-mode:forward-char  {C-f}'
     Move point forward ARG (or 1) characters and return point.

`kotl-mode:forward-para  {M-n}'
     Move to prefix ARGth next cell (any level) within current view.

`kotl-mode:forward-paragraph  {M-]}'
     Move to prefix ARGth next cell (any level) within current view.

`kotl-mode:forward-sentence  {M-e}'
     Move point forward ARG (or 1) sentences and return point.

`kotl-mode:forward-word  {M-f}'
     Move point forward ARG (or 1) words and return point.

`kotl-mode:goto-cell  {C-c g}'
     Move point to start of cell given by CELL-REF.  (See
     'kcell:ref-to-id'.)  Return point iff CELL-REF is found within
     current view.  With a prefix argument, CELL-REF is assigned the
     argument value for use as an idstamp.

     Optional second arg, ERROR-P, non-nil means signal an error if
     CELL-REF is not found within current view.  Will signal same error
     if called interactively when CELL-REF is not found.

`kotl-mode:hide-sublevels  {C-X $}'
     Hide all cells in outline at levels deeper than LEVELS-TO-KEEP (a
     number). Shows any hidden cells within LEVELS-TO-KEEP.  1 is the
     first level.

`kotl-mode:hide-subtree  {C-M-h}'
     Hide subtree, ignoring root, at optional CELL-REF (defaults to
     cell at point).

`kotl-mode:hide-tree  {C-c BS}'
     Collapse kotl rooted at optional CELL-REF (defaults to cell at
     point).

`kotl-mode:insert-file  {C-x i}'
     Insert each paragraph in IMPORT-FROM as a separate cell in the
     current view.  Insert as sibling cells following the current cell.
     IMPORT-FROM may be a buffer name or file name (file name
     completion is provided).

`kotl-mode:insert-register  {C-c r i}'
     Insert contents of register REGISTER at point in current cell.
     REGISTER is a character naming the register to insert.  Normally
     puts point before and mark after the inserted text.  If optional
     second arg is non-nil, puts mark before and point after.
     Interactively, second arg is non-nil if prefix arg is supplied.

`kotl-mode:just-one-space  {M-\}'
     Delete all spaces and tabs around point and leave one space.

`kotl-mode:kcell-help  {C-c h}'
     Display a temporary buffer with CELL-REF's properties.  CELL-REF
     defaults to current cell.  Optional prefix arg CELLS-FLAG selects
     the cells to print:   If = 1, print CELL-REF's cell only;   If >
     1, print CELL-REF's visible kotl (the tree rooted at CELL-REF);
     If < 1, print all visible cells in current view  (CELL-REF is not
     used).

     See also the documentation for `kotl-mode:properties'.

`kotl-mode:kill-contents  {C-c k}'
     Kill contents of cell from point to cell end.  With prefix ARG,
     kill entire cell contents.

`kotl-mode:kill-line  {C-k}'
     Kill ARG lines from point.

`kotl-mode:kill-region  {C-w}'
     Kill region between START and END within a single kcell.  With
     optional COPY-P equal to 't, copy region to kill ring but does not
     kill it.  With COPY-P any other non-nil value, return region as a
     string without affecting kill ring.

     If the buffer is read-only and COPY-P is nil, the region will not
     be deleted but it will be copied to the kill ring and then an
     error will be signaled.

`kotl-mode:kill-ring-save  {M-w}'
     Copy region between START and END within a single kcell to kill
     ring.

`kotl-mode:kill-sentence  {M-k}'
     Kill up to prefix ARG (or 1) sentences following point within a
     single cell.

`kotl-mode:kill-tree  {C-c C-k}'
     Kill ARG following trees starting with tree rooted at point.  If
     ARG is not a non-positive number, nothing is done.

`kotl-mode:kill-word  {M-d}'
     Kill up to prefix ARG words following point within a single cell.

`kotl-mode:last-sibling  {C-c >}'
     Move point to the last sibling of the present cell.  Leave point
     at the start of the cell or at its present position if it is
     already within the last sibling cell.

`kotl-mode:mail-tree  {C-c @}'
     Mail outline tree rooted at CELL-REF.  Use "0" for whole outline
     buffer.

`kotl-mode:move-after  {C-c m}'
     Move tree rooted at FROM-CELL-REF to follow tree rooted at
     TO-CELL-REF.  If prefix arg CHILD-P is non-nil, make FROM-CELL-REF
     the first child of TO-CELL-REF, otherwise make it the sibling
     following TO-CELL-REF.  With optional COPY-P, copies tree rather
     than moving it.

     Leave point at original location but return the tree's new start
     point.

`kotl-mode:move-before  {C-c RET}'
     Move tree rooted at FROM-CELL-REF to precede tree rooted at
     TO-CELL-REF.  If prefix arg PARENT-P is non-nil, make
     FROM-CELL-REF the first child of TO-CELL-REF's parent, otherwise
     make it the preceding sibling of TO-CELL-REF.  With optional
     COPY-P, copies tree rather than moving it.

     Leave point at original location but return the tree's new start
     point.

`kotl-mode:newline  {RET}'
     Insert a newline.  With ARG, insert ARG newlines.  In Auto Fill
     mode, if no numeric arg, break the preceding line if it is too
     long.

`kotl-mode:next-cell  {C-c C-n}'
     Move to prefix ARGth next cell (any level) within current view.

`kotl-mode:next-line  {C-n}'
     Move point to ARGth next line and return point.

`kotl-mode:open-line  {C-o}'
     Insert a newline and leave point before it.  With arg N, insert N
     newlines.

`kotl-mode:overview  {C-c C-o}'
     Show only the first line of each cell in the current outline.

`kotl-mode:previous-cell  {C-c C-p}'
     Move to prefix ARGth previous cell (any level) within current view.

`kotl-mode:previous-line  {C-p}'
     Move point to ARGth previous line and return point.

`kotl-mode:promote-tree  {M-TAB}'
     Move current kotl a maximum of prefix ARG levels higher in current
     view.  Each cell is refilled iff its _no-fill_ attribute is nil and
     KOTL-MODE:REFILL-FLAG is non-nil.  With prefix ARG = 0, cells are
     promoted up to one level and kotl-mode:refill-flag is treated as
     true.

`kotl-mode:scroll-down  {M-v}'
     Scroll text of current window downward ARG lines; or a windowful
     if no ARG.

`kotl-mode:scroll-up  {C-v}'
     Scroll text of current window upward ARG lines; or a windowful if
     no ARG.

`kotl-mode:set-cell-attribute  {C-c C-i}'
     Include ATTRIBUTE VALUE with the current cell or the cell at
     optional POS.  Replaces any existing value that ATTRIBUTE has.
     When called interactively, it displays the setting in the
     minibuffer as confirmation.

`kotl-mode:set-fill-prefix  {C-x l}'
     Sets fill prefix to line up to point.  With prefix arg TURN-OFF or
     at begin of line, turns fill prefix off.

`kotl-mode:show-all  {C-c C-a}'
     Show (expand) all cells in current view.

`kotl-mode:show-subtree'
     Show subtree, ignoring root, at optional CELL-REF (defaults to
     cell at point).

`kotl-mode:show-tree  {C-c C-s}'
     Display fully expanded kotl rooted at CELL-REF.

`kotl-mode:split-cell  {C-c s}'
     Split cell into two cells and move to new cell.  Cell contents
     after point become part of newly created cell.  Default is to
     create new cell as sibling of current cell.  With optional
     universal ARG, `C-u', new cell is added as child of current cell.

`kotl-mode:top-cells  {C-c C-t}'
     Collapse all level 1 cells in view and hide any deeper sublevels.

`kotl-mode:transpose-cells  {C-c t}'
     Exchange current and previous visible cells, leaving point after
     both.  If no previous cell, exchange current with next cell.  With
     prefix ARG, take current cell and move it past ARG cells.  With
     prefix ARG = 0, interchange the cell that contains point with the
     cell that contains mark.

`kotl-mode:transpose-chars  {C-t}'
     Interchange characters around point, moving forward one character.
     With prefix ARG, take character before point and drag it forward
     past ARG other characters (backward if ARG negative).  If no
     prefix ARG and at end of line, the previous two characters are
     exchanged.

`kotl-mode:transpose-lines  {C-x C-t}'
     Exchange current line and previous line, leaving point after both.
     If no previous line, exchange current with next line.  With prefix
     ARG, take previous line and move it past ARG lines.  With prefix
     ARG = 0, interchange the line that contains point with the line
     that contains mark.

`kotl-mode:transpose-words  {M-t}'
     Interchange words around point, leaving point after both words.
     With prefix ARG, take word before or around point and drag it
     forward past ARG other words (backward if ARG negative).  If ARG
     is zero, the words around or after point and around or after mark
     are interchanged.

`kotl-mode:up-level  {C-c C-u}'
     Move up prefix ARG levels higher in current outline view.

`kotl-mode:yank  {C-y}'
     Reinsert the last stretch of killed text.  More precisely,
     reinsert the stretch of killed text most recently killed OR
     yanked.  Put point at end, and set mark at beginning.  With just
     C-u as argument, same but put point at beginning (and mark at end).
     With argument N, reinsert the Nth most recently killed stretch of
     killed text.  See also the command M-x kotl-mode:yank-pop.

`kotl-mode:yank-pop  {M-y}'
     Replace just-yanked stretch of killed text with a different
     stretch.  This command is allowed only immediately after a `yank'
     or a `yank-pop'.  At such a time, the region contains a stretch of
     reinserted previously-killed text.  `yank-pop' deletes that text
     and inserts in its place a different stretch of killed text.

     With no argument, the previous kill is inserted.  With argument N,
     insert the Nth previous kill.  If N is negative, this is a more
     recent kill.

     The sequence of kills wraps around, so that after the oldest one
     comes the newest one.

`kotl-mode:zap-to-char  {M-z}'
     Kill up to and including prefix ARG'th occurrence of CHAR.  Goes
     backward if ARG is negative; error if CHAR not found.

`kview:set-label-type  {C-c C-l}'
     Change kview's label display type to NEW-TYPE, updating all
     displayed labels.  See documentation for variable,
     kview:default-label-type, for valid values of NEW-TYPE.

`kvspec:activate  {C-c C-v}'
     Activate optional VIEW-SPEC or existing view spec in the current
     koutline.  VIEW-SPEC is a string.  See
     <${hyperb:dir}/kotl/EXAMPLE.kotl, 2b17=048> for details on valid
     view specs.

`kvspec:toggle-blank-lines {C-c b}'
     Toggle blank lines between cells on or off.



File: hyperbole.info,  Node: Suggestion or Bug Reporting,  Next: Questions and Answers,  Prev: Outliner Keys,  Up: Top

Appendix D Suggestion or Bug Reporting
**************************************

*Note Mail Lists::, for complete details on Hyperbole mailing lists and
how to subscribe.

   If you find any errors in Hyperbole's operation or documentation,
feel free to report them to the Hyperbole bug list:
<bug-hyperbole@gnu.org>.  You need to be subscribed to the list todo
that. See *Note Mail Lists::, for details. Be sure to use the
Msg/Compose-Hypb-Mail minibuffer menu item whenever you send a message
to the mail list since it will insert important system version
information for you.

   If you use Hyperbole mail or news support, *Note Buttons in Mail::, a
click with your Action Key on the Hyperbole mail list address will
insert a description of your Hyperbole configuration information into
your outgoing message, so that you do not have to type it.  This is
useful when composing a reply for the Hyperbole mail list.  Otherwise,
be sure to include your Emacs, Hyperbole and window system versions in
your message.  Your Hyperbole version number can be found in the
top-level Hyperbole menu.

   Please use your subject line to state the position that your message
takes on the topic that it addresses, e.g. send "Subject: Basic bug in
top-level Hyperbole menu." rather than "Subject: Hyperbole bug".  This
simple rule makes all e-mail communication much easier.

   If you have suggestions on how to improve Hyperbole, send them to the
same address.  Here are some issues you might address:

   * What did you like and dislike about the system?

   * What kinds of tasks, if any, does it seem to help you with?

   * What did you think of the Emacs-based user interface?

   * How was the Hyperbole Manual and other documentation?

   * Was the setup trivial, average or hard?

   * What areas of Hyperbole would you like to see expanded/added?

   * How does it compare to other hypertext tools you have used?

   * Was it easy or difficult to create your own types?  Why?

   * Did you get any use out of the external system encapsulations?


File: hyperbole.info,  Node: Questions and Answers,  Next: Future Work,  Prev: Suggestion or Bug Reporting,  Up: Top

Appendix E Questions and Answers
********************************

_How can I change the Smart Mouse Key bindings?_
     Since the Smart Mouse Keys are set up for use under five different
     Emacs configurations, there is no easy way to provide user level
     customization.  The command, `hmouse-shift-buttons', can be used to
     select between shifted and unshifted Smart Mouse Keys.  Any other
     mouse key binding changes must be done by editing the
     `hmouse-setup' and `hmouse-get-bindings' functions in the
     `hmouse-sh.el' and `hmouse-reg.el' files.

     The HKEY-ALIST and HMOUSE-ALIST variable settings in
     `hui-mouse.el' and `hui-window.el' must be altered if you want to
     change what the Smart Keys do in particular contexts.  You should
     then update the Smart Key summary documentation in the file,
     `hypb-mouse.txt', and potentially the same summary in this manual.

_Missing Action Types_
     What if someone sends a mail message with a button for which I do
     not have the action type?  Or a button whose link referent I can't
     access?

     You receive an error that an action type is not defined or a link
     referent is not accessible/readable if you try to use the button.
     This is hardly different than trying to get through a locked door
     without a key; you try the doorknob, find that it is locked, and
     then realize that you need to take a different approach or else
     give up.

     Like all communication, people need to coordinate, which usually
     requires an iterative process.  If you get a mail message with a
     button for which you don't have the action type, you mail the
     sender and request it.

_How can I modify a number of global buttons in succession?_
     Rather than typing the name for each, it is quicker to jump to the
     global button file and edit the buttons there as you would any
     explicit buttons.  By default, the ButFile/PersonalFile menu item
     takes you to the file where global buttons are saved.

_Why is all the button data scattered across directories?_
     When you think of a hyper-space that you depend on every day, you
     don't want to have a single point of failure make you incapable of
     doing work.  With Hyperbole, if some directories become
     unavailable for a particular time (e.g. the filesystems on which
     they reside are dismounted) you can still work elsewhere with
     minimal effect.  We believe this to be a compelling factor to
     leave the design with external button data storage.

     This design also permits the potential addition of buttons to
     read-only media.

_Why are action types defined separately from their implicit button types?_
     Any category of button can make use of an action type.  Some
     action types are useful as behavior definitions for a variety of
     button categories, so all action types are defined separately to
     give them independence from those types which apply them.

     For implicit button types that require a lot of code, it is useful
     to add a module that includes the implicit button type definition,
     its action type definition and supporting code.



File: hyperbole.info,  Node: Future Work,  Next: References,  Prev: Questions and Answers,  Up: Top

Appendix F Future Work
**********************

This appendix is included for a number of reasons:

   * to better allow you to assess whether to work with Hyperbole by
     providing sketches of possible additions:

   * to direct further development effort towards known needs;

   * and to acknowledge known weaknesses in the current system.

     Note that due to a lack of volunteers to further develop
     Hyperbole, much of this work may not be done.  So if you want to
     see these features, encourage qualified people to volunteer.

Button Copying, Killing, and Yanking
     There is as yet no means of transferring explicit buttons among
     buffers.  We realize this is a critical need.  Users should be
     able to manipulate text with embedded buttons in ordinary ways.
     This will probably be implemented only for versions of Emacs 19
     and higher.  It will store the button attributes as text
     attributes within the buffers so that if a button is copied, its
     attributes follow.  When a buffer is saved, the attributes also
     will be saved.

Trails
     Trails are an extension to the basic history mechanism presently
     offered by Hyperbole.  Trails will allow a user to capture, edit
     and store a specific sequence and set of views of information for
     later replay by other users.  Conditional branching may also be
     supported.

Outliner View Mode
     This will complement the outliner editing mode by using simple one
     character keys that normally insert characters to instead modify
     the view of an outline and to move around in it, for ease of study.
     Switching between view and edit modes will also be simple.

Storage of button data within button source files
     The current design choice of storing buttons external to the
     source file was made under the assumption that people should be
     able to look at files that contain Hyperbole buttons with any
     standard editor or tool and not be bothered by the ugly button
     data (since they won't be able to utilize the buttons anyway, they
     don't need to see or have access to them).

     In many contexts, embedding the button data within the source
     files may be a better choice, so a provision which would allow
     selection of either configuration may be added.  Here are some of
     the PROs and CONs of both design choices:

                     POSITIVE                        NEGATIVE

          Button data in source file
                     Documents can stand alone.      All edit operators have
                     Normal file operations apply.   to account for file
                                                     structure and hide
                     Simplifies creation and         internal components.
                     facility expansion for
                     structured and multi-media
                     files.

          Button data external to source file
                     Files can be displayed and      Currently, bdata for
                     printed exactly as they look.   whole directory is
                     No special display formatting   locked when any bdata
                     is necessary.                   entry is locked.

                     Button-based searches and
                     database-type lookup operations
                     need only search one file
                     per directory.



Forms-based Interfaces
     This will allow one to create buttons more flexibly.  For example,
     button attributes could be given in any order.  Entry of long code
     sequences, quick note taking and cross-referencing would also be
     made easier.

Collaboration Support
     From the early stages of Hyperbole design, collaborative work
     environments have been considered.  A simple facility has
     demonstrated broadcast of button activations to a number of
     workstations on a local area network, so that one user can lead
     others around an information space, as during an online design
     review.  (This facility was never adapted to the current Hyperbole
     release, however.)  We shall do some work in specific
     collaborative mechanisms, but we also expect that others who
     concentrate in collaborative work will provide more extensive
     capabilities.



File: hyperbole.info,  Node: References,  Next: Key Binding Index,  Prev: Future Work,  Up: Top

Appendix G References
*********************

[AkMcYo88]
     Akscyn, R. M., D. L. McCracken and E. A. Yoder. KMS: A Distributed
     Hypermedia System for Managing Knowledge in Organizations.
     _Communications of the ACM_, Vol. 31, No. 7, July 1988, pp.
     820-835.

[Bro87]
     Brown, P. J. Turning Ideas into Products: The Guide System.
     _Proceedings of Hypertext '87_, November 13-15, 1987, Chapel Hill,
     NC.  ACM: NY, NY, pp. 33-40.

[Con87]
     Conklin, Jeff. Hypertext: An Introduction and Survey. _IEEE
     Computer_, Vol. 20, No. 9, September 1987, pp. 17-41.

[Eng68]
     Engelbart, D., and W. English.  A research center for augmenting
     human intellect. _Proceedings of the Fall Joint Computer
     Conference_, 33, 1, AFIPS Press: Montvale, NJ, 1968, pp. 395-410.

[Eng84a]
     Engelbart, D. C. Authorship Provisions in Augment.  _Proceedings
     of the 1984 COMPCON Conference (COMPCON '84 Digest)_, February
     27-March 1, 1984, San Francisco, CA. IEEE Computer Society Press,
     Spring, 1984.  465-472. (OAD,2250,)

[Eng84b]
     Engelbart, D. C. Collaboration Support Provisions in Augment.
     _Proceedings of the AFIPS Office Automation Conference (OAC '84
     Digest)_, February, 1984, Los Angeles, CA, 1984. 51-58. (OAD,2221,)

[Fos88]
     Foss, C. L. Effective Browsing in Hypertext Systems.  _Proceedings
     of the Conference on User-Oriented Content-Based Text and Image
     Handling (RIAO 88)_, March 21-24, MIT, Cambridge MA. Centre de
     Hautes Etudes Internationales d'Informatique Documentaire, 1988,
     pp. 82-98.

[GaSmMe86]
     Garrett, N., K. E. Smith and N. Meyrowitz. Intermedia: Issues,
     Strategies, and Tactics in the Design of a Hypermedia Document
     System.  _Computer-Supported Cooperative Work (CSCW '86)
     Proceedings_, December 3-5, Austin, TX, 1986, pp. 163-174.

[HaMoTr87]
     Halasz, F. G., T. P. Moran and R. H. Trigg. NoteCards in a
     Nutshell. _Proceedings of the CHI and GI '87 Conference on Human
     Factors in Computing Systems_, Toronto, J. M. Carroll and P. P.
     Tanner, (editors), ACM: NY, NY, April 1987, pp. 45-52.

[Har88]
     Harvey, G. _Understanding HyperCard._ Alameda, CA: SYBEX, Inc.,
     1988.

[KaCaLoLa92]
     Kaplan, S., A. M. Carroll, C. Love and D. M. LaLiberte.  _Epoch
     4.0 Manual._ Department of Computer Science, University of
     Illinois, Urbana, March 1992.

[KaKaBeLaDr90]
     Kaplan, S. J., M. D. Kapor, E. J. Belove, R. A.  Landsman, and T.
     R. Drake.  AGENDA: A personal Information Manager.  _Communications
     of the ACM_, No. 33, July 1990, pp. 105-116.

[Nel87a]
     Nelson, T. H.  _Computer Lib/Dream Machines._ MicroSoft Press,
     Redmond, WA, 1987.

[Nel87b]
     Nelson, T. H. _Literary Machines, Edition 87.1_.  Available from
     the Distributors, 702 South Michigan, South Bend, IN 46618, 1987.

[NoDr86]
     Norman, D. A. and S. W. Draper, editors.  _User Centered System
     Design._ Lawrence Erlbaum Associates: Hillsdale, New Jersey, 1986.

[Shn82]
     Shneiderman, B. The future of interactive systems and the emergence
     of direct manipulation.  _Behavior and Information Technology_,
     Vol. 1, 1982, pp. 237-256.

[Sta87]
     Stallman, R.  _GNU Emacs Manual._ Free Software Foundation,
     Cambridge: MA, March 1987.

[Tri86]
     Trigg, R., L. Suchman, and F. Halasz.  Supporting collaboration in
     NoteCards.  _Proceedings of the CSCW '86 Conference_, Austin, TX,
     December 1986, pp. 147-153.

[TrMoHa87]
     Trigg, R. H., T. P. Moran and F. G. Halasz.  Adaptability and
     Tailorability in NoteCards. _Proceedings of INTERACT '87_,
     Stuttgart, West Germany, September 1987.

[Wei92]
     Weiner, B.  _PIEmail: A Personalized Information Environment Mail
     Tool._  Department of Computer Science Masters Project, Brown
     University: Providence, RI, May 10, 1992.

[YaHaMeDr88]
     Yankelovich, N., B. J. Haan, N. Meyrowitz and S. M.  Drucker.
     Intermedia: The Concept and the Construction of a Seamless
     Information Environment. _IEEE Computer_, Vol. 21, No. 1, January
     1988, pp.  81-96.

[YoAkMc89]
     Yoder, E. A., R. M. Akscyn and D. L. McCracken.  Collaboration in
     KMS, A Shared Hypermedia System. _Proceedings of the 1989 ACM
     Conference on Human Factors in Computer Systems (CHI '89)_, April
     30-May 4, 1989, Austin, TX, ACM: NY,NY, 1989, pp. 37-42.



File: hyperbole.info,  Node: Key Binding Index,  Next: Code and File Index,  Prev: References,  Up: Top

Key Binding Index
*****************

 [index ]
* Menu:

* ,:                                     Rolo Keys.           (line  54)
* .:                                     Rolo Keys.           (line  50)
* <:                                     Rolo Keys.           (line  50)
* <DEL>:                                 Rolo Keys.           (line  58)
* <SPC>:                                 Rolo Keys.           (line  61)
* <TAB>:                                 Relocating and Copying.
                                                              (line  12)
* >:                                     Rolo Keys.           (line  54)
* a:                                     Rolo Keys.           (line  27)
* Action Key:                            Smart Keys.          (line   6)
* Action Key, cell argument:             Relocating and Copying.
                                                              (line  21)
* Action Key, hide or show cell:         Hiding and Showing.  (line  43)
* Action Key, klink:                     Links.               (line  13)
* Action Key, web browsing:              Implicit Buttons.    (line 132)
* Assist Key:                            Smart Keys.          (line   6)
* Assist Key, listing attributes:        Cell Attributes.     (line  33)
* b:                                     Rolo Keys.           (line  37)
* C-c $:                                 Moving Around.       (line  40)
* C-c +:                                 Splitting and Appending.
                                                              (line  16)
* C-c ,:                                 Moving Around.       (line   9)
* C-c .:                                 Moving Around.       (line  10)
* C-c <:                                 Moving Around.       (line  33)
* C-c >:                                 Moving Around.       (line  34)
* C-c @:                                 Relocating and Copying.
                                                              (line  70)
* C-c ^:                                 Moving Around.       (line  39)
* C-c a:                                 Adding and Killing.  (line   6)
* C-c b:                                 View Specs.          (line  33)
* C-c c:                                 Relocating and Copying.
                                                              (line  34)
* C-c C-a:                               Hiding and Showing.  (line  19)
* C-c C-b:                               Moving Around.       (line  22)
* C-c C-c:                               Relocating and Copying.
                                                              (line  40)
* C-c C-d:                               Moving Around.       (line  27)
* C-c C-f:                               Moving Around.       (line  21)
* C-c C-h:                               Hiding and Showing.  (line  13)
* C-c C-i:                               Cell Attributes.     (line  22)
* C-c C-k:                               Adding and Killing.  (line  14)
* C-c C-l:                               Autonumbering.       (line  34)
* C-c C-m:                               Relocating and Copying.
                                                              (line  52)
* C-c C-n:                               Moving Around.       (line  15)
* C-c C-o:                               Hiding and Showing.  (line  34)
* C-c C-p:                               Moving Around.       (line  16)
* C-c C-r:                               Renaming.            (line  21)
* C-c C-s:                               Hiding and Showing.  (line  14)
* C-c C-t:                               Hiding and Showing.  (line  37)
* C-c C-u:                               Moving Around.       (line  28)
* C-c C-v:                               View Specs.          (line  24)
* C-c C-y:                               Buttons in Mail.     (line  21)
* C-c e:                                 Transposing.         (line  10)
* C-c h:                                 Cell Attributes.     (line  36)
* C-c k:                                 Adding and Killing.  (line  14)
* C-c l:                                 Links.               (line  18)
* C-c m:                                 Relocating and Copying.
                                                              (line  46)
* C-c M-c:                               Relocating and Copying.
                                                              (line  69)
* C-c M-j:                               Filling.             (line  11)
* C-c M-l:                               Autonumbering.       (line  44)
* C-c M-q:                               Filling.             (line  11)
* C-c p:                                 Adding and Killing.  (line   6)
* C-c s:                                 Splitting and Appending.
                                                              (line   6)
* C-c t <1>:                             Transposing.         (line  13)
* C-c t:                                 Smart Keys.          (line 154)
* C-g:                                   Menus.               (line  81)
* C-h A:                                 Smart Keys.          (line 147)
* C-h h <1>:                             Menus.               (line  19)
* C-h h:                                 Installing.          (line  70)
* C-h t:                                 Top.                 (line  79)
* C-j:                                   Adding and Killing.  (line   6)
* C-M-h:                                 Hiding and Showing.  (line  26)
* C-M-j:                                 Filling.             (line  11)
* C-M-q:                                 Filling.             (line  11)
* C-M-x:                                 Creating Types.      (line   8)
* C-r:                                   Rolo Keys.           (line  21)
* C-t:                                   Menus.               (line  81)
* C-u C-c c:                             Relocating and Copying.
                                                              (line  35)
* C-u C-c C-c:                           Relocating and Copying.
                                                              (line  41)
* C-u C-c C-m:                           Relocating and Copying.
                                                              (line  53)
* C-u C-c h:                             Cell Attributes.     (line  36)
* C-u C-c k:                             Adding and Killing.  (line  14)
* C-u C-c m:                             Relocating and Copying.
                                                              (line  47)
* C-u C-c M-l:                           Autonumbering.       (line  44)
* C-u C-c s:                             Splitting and Appending.
                                                              (line   6)
* C-u c-j:                               Adding and Killing.  (line   6)
* C-u C-x i:                             Inserting and Importing.
                                                              (line  11)
* C-u M-o:                               By Dragging.         (line  26)
* C-u M-RET:                             Smart Keys.          (line  21)
* C-x $:                                 Hiding and Showing.  (line  20)
* C-x C-e:                               Creating Types.      (line   8)
* C-x i:                                 Inserting and Importing.
                                                              (line   6)
* C-x m:                                 Buttons in Mail.     (line   6)
* C-x o:                                 By Dragging.         (line  26)
* C-y:                                   Adding and Killing.  (line  14)
* e:                                     Rolo Keys.           (line   6)
* f:                                     Rolo Keys.           (line  38)
* h:                                     Rolo Keys.           (line  27)
* M-0 C-c t:                             Transposing.         (line  17)
* M-<RET>:                               Hiding and Showing.  (line  43)
* M-<TAB>:                               Relocating and Copying.
                                                              (line  12)
* M-j:                                   Filling.             (line  11)
* M-o:                                   By Dragging.         (line  26)
* M-q:                                   Filling.             (line  11)
* M-RET:                                 Smart Keys.          (line  21)
* M-s:                                   Rolo Keys.           (line  21)
* M-TAB:                                 Rolo Keys.           (line  14)
* n:                                     Rolo Keys.           (line  41)
* p:                                     Rolo Keys.           (line  44)
* q <1>:                                 Rolo Keys.           (line  66)
* q:                                     Menus.               (line  81)
* r:                                     Rolo Keys.           (line  14)
* s:                                     Rolo Keys.           (line  27)
* t:                                     Rolo Keys.           (line  27)
* TAB:                                   Rolo Keys.           (line  14)
* u:                                     Rolo Keys.           (line  47)


File: hyperbole.info,  Node: Code and File Index,  Next: Concept Index,  Prev: Key Binding Index,  Up: Top

Code and File Index
*******************

 [index ]
* Menu:

* action-key:                            Smart Keys.          (line  27)
* action-key-default-function <1>:       Menus.               (line  19)
* action-key-default-function:           Smart Keys.          (line 124)
* action-key-url-function <1>:           Action Types.        (line 137)
* action-key-url-function:               Implicit Buttons.    (line 132)
* action-mouse-key:                      Smart Keys.          (line  27)
* action:act-hook:                       Hook Variables.      (line  24)
* actype:create:                         Action Type Creation.
                                                              (line   6)
* actype:delete:                         Action Type Creation.
                                                              (line  74)
* actypes::annot-bib:                    Action Types.        (line  15)
* actypes::completion:                   Action Types.        (line  19)
* actypes::eval-elisp:                   Action Types.        (line  24)
* actypes::exec-kbd-macro:               Action Types.        (line  27)
* actypes::exec-shell-cmd:               Action Types.        (line  32)
* actypes::exec-window-cmd:              Action Types.        (line  38)
* actypes::hyp-config:                   Action Types.        (line  41)
* actypes::hyp-request:                  Action Types.        (line  45)
* actypes::hyp-source:                   Action Types.        (line  49)
* actypes::kbd-key:                      Action Types.        (line  53)
* actypes::link-to-buffer-tmp:           Action Types.        (line  57)
* actypes::link-to-directory:            Action Types.        (line  62)
* actypes::link-to-doc:                  Action Types.        (line  65)
* actypes::link-to-ebut:                 Action Types.        (line  70)
* actypes::link-to-elisp-doc:            Action Types.        (line  74)
* actypes::link-to-file:                 Action Types.        (line  77)
* actypes::link-to-file-line:            Action Types.        (line  82)
* actypes::link-to-Info-node:            Action Types.        (line 101)
* actypes::link-to-kcell:                Action Types.        (line  85)
* actypes::link-to-kotl:                 Action Types.        (line  91)
* actypes::link-to-mail:                 Action Types.        (line 105)
* actypes::link-to-regexp-match:         Action Types.        (line 110)
* actypes::link-to-rfc:                  Action Types.        (line 114)
* actypes::link-to-string-match:         Action Types.        (line 119)
* actypes::man-show:                     Action Types.        (line 123)
* actypes::rfc-toc:                      Action Types.        (line 127)
* actypes::text-toc:                     Action Types.        (line 133)
* actypes::www-url:                      Action Types.        (line 137)
* assist-key:                            Smart Keys.          (line  27)
* assist-key-default-function:           Smart Keys.          (line 124)
* assist-mouse-key:                      Smart Keys.          (line  27)
* class, ebut <1>:                       Programmatic Button Creation.
                                                              (line  13)
* class, ebut:                           Operational and Storage Formats.
                                                              (line  17)
* class, hargs:                          Action Type Creation.
                                                              (line  61)
* class, hattr:                          Implicit Button Types.
                                                              (line  43)
* class, hbdata:                         Operational and Storage Formats.
                                                              (line  17)
* class, hbut <1>:                       Operational and Storage Formats.
                                                              (line  17)
* class, hbut:                           Implicit Button Types.
                                                              (line  43)
* class, htype:                          Creating Types.      (line  15)
* defact:                                Action Type Creation.
                                                              (line  10)
* defib:                                 Implicit Button Types.
                                                              (line   6)
* dir, ~/.hyperb:                        Button Files.        (line  18)
* ebut:create:                           Programmatic Button Creation.
                                                              (line  13)
* ebut:create-hook:                      Hook Variables.      (line  28)
* ebut:delete-hook:                      Hook Variables.      (line  31)
* ebut:map:                              Programmatic Button Creation.
                                                              (line  13)
* ebut:modify-hook:                      Hook Variables.      (line  34)
* EMACS, environment variable:           Building.            (line  10)
* emacs-version:                         Mail Lists.          (line  45)
* eval-defun:                            Creating Types.      (line   8)
* eval-last-sexp:                        Creating Types.      (line   8)
* file, .hypb:                           Explicit Buttons.    (line  14)
* file, .kotl suffix:                    Creating Outlines.   (line   6)
* file, .~/.emacs:                       Renaming.            (line  21)
* file, DEMO:                            Top.                 (line  79)
* file, DIR:                             Implicit Buttons.    (line  33)
* file, EXAMPLE.kotl:                    Outliner.            (line  27)
* file, hactypes.el <1>:                 Action Type Creation.
                                                              (line   6)
* file, hactypes.el:                     Creating Types.      (line  18)
* file, hbut.el <1>:                     Programmatic Button Creation.
                                                              (line  13)
* file, hbut.el:                         Action Type Creation.
                                                              (line   6)
* file, hgnus.el:                        Buttons in News.     (line   6)
* file, hib-kbd.el:                      Implicit Button Types.
                                                              (line  43)
* file, hibtypes.el <1>:                 Creating Types.      (line  18)
* file, hibtypes.el:                     Implicit Buttons.    (line  14)
* file, hmail.el:                        Buttons in Mail.     (line  12)
* file, hmouse-key.el:                   Questions and Answers.
                                                              (line  15)
* file, hmouse-reg.el:                   Questions and Answers.
                                                              (line   6)
* file, hmouse-sh.el:                    Questions and Answers.
                                                              (line   6)
* file, hsite.el <1>:                    Smart Keys.          (line 154)
* file, hsite.el <2>:                    Buttons in News.     (line   6)
* file, hsite.el <3>:                    Renaming.            (line  21)
* file, hsite.el <4>:                    Button Colors.       (line  16)
* file, hsite.el <5>:                    External Viewers.    (line   6)
* file, hsite.el <6>:                    Internal Viewers.    (line   6)
* file, hsite.el <7>:                    Configuring.         (line   6)
* file, hsite.el <8>:                    Installing.          (line  11)
* file, hsite.el <9>:                    Building.            (line   6)
* file, hsite.el:                        Installation.        (line  10)
* file, hsys-*:                          Encapsulating Systems.
                                                              (line   6)
* file, hui-ep*.el:                      Button Colors.       (line   6)
* file, hui-window.el:                   Questions and Answers.
                                                              (line  15)
* file, hversion.el:                     Installing.          (line  18)
* file, HYPB:                            Menus.               (line  34)
* file, hyperbole.el <1>:                Configuring.         (line   6)
* file, hyperbole.el:                    Installing.          (line  18)
* file, Makefile:                        Building.            (line   6)
* file, man/hyperbole.info:              Installing.          (line  44)
* file, man/hyperbole.ps:                Building.            (line  34)
* file, man/hyperbole.texi:              Installing.          (line  44)
* file, MANIFEST:                        Implicit Buttons.    (line  33)
* file, wconfig.el:                      Window Configurations.
                                                              (line   6)
* file, wrolo.el:                        Rolodex.             (line  12)
* file, ~/.emacs <1>:                    Autonumbering.       (line  52)
* file, ~/.emacs <2>:                    Smart Keys.          (line 154)
* file, ~/.emacs <3>:                    Buttons in Mail.     (line  55)
* file, ~/.emacs:                        Installing.          (line  11)
* fill-column:                           Outliner Keys.       (line  79)
* fill-prefix:                           Button Label Normalization.
                                                              (line  25)
* find-file-hooks:                       Hook Variables.      (line  74)
* gbut:file:                             Glossary.            (line 147)
* hbmap:dir-user:                        Button Files.        (line  18)
* hbmap:filename:                        Button Files.        (line  13)
* hbut:current <1>:                      Operational and Storage Formats.
                                                              (line   6)
* hbut:current:                          Hook Variables.      (line  24)
* hbut:fill-prefix-regexps:              Button Label Normalization.
                                                              (line  25)
* hbut:label-to-key:                     Button Label Normalization.
                                                              (line   6)
* hibtypes:begin-load-hook:              Hook Variables.      (line  37)
* hibtypes:end-load-hook:                Hook Variables.      (line  42)
* hkey-alist:                            Questions and Answers.
                                                              (line  15)
* hkey-init:                             Smart Keys.          (line  21)
* hkey-operate:                          By Dragging.         (line  26)
* hmouse-alist:                          Questions and Answers.
                                                              (line  15)
* hmouse-get-bindings:                   Questions and Answers.
                                                              (line   6)
* hmouse-setup:                          Questions and Answers.
                                                              (line   6)
* hmouse-shift-buttons <1>:              Questions and Answers.
                                                              (line   7)
* hmouse-shift-buttons:                  Smart Keys.          (line  14)
* hpath:at-p:                            Implicit Buttons.    (line 102)
* hpath:display-alist:                   Internal Viewers.    (line   6)
* hpath:find:                            Implicit Buttons.    (line 102)
* hpath:find-alist:                      External Viewers.    (line   6)
* hpath:suffixes:                        Implicit Buttons.    (line 102)
* hpath:variables:                       Link Variable Substitution.
                                                              (line   6)
* hproperty:but-create:                  Button Colors.       (line  22)
* hproperty:but-emphasize-p:             Button Colors.       (line  16)
* hproperty:cycle-but-color:             Button Colors.       (line   6)
* htype:create-hook:                     Hook Variables.      (line  47)
* htype:delete-hook:                     Hook Variables.      (line  51)
* hui:ebut-delete-confirm-p:             Deletion.            (line  11)
* hui:ebut-prompt-for-action:            Action Types.        (line 141)
* hyperb:dir:                            Installing.          (line  18)
* hyperb:init-hook:                      Hook Variables.      (line  18)
* hyperbole:                             Installing.          (line  70)
* ibtype:create:                         Implicit Button Types.
                                                              (line   6)
* ibtype:delete:                         Implicit Button Types.
                                                              (line  37)
* ibtypes::annot-bib:                    Implicit Buttons.    (line  24)
* ibtypes::completion:                   Implicit Buttons.    (line  30)
* ibtypes::debugger-source:              Implicit Buttons.    (line  50)
* ibtypes::dir-summary:                  Implicit Buttons.    (line  33)
* ibtypes::doc-id:                       Implicit Buttons.    (line  39)
* ibtypes::elisp-compiler-msg:           Implicit Buttons.    (line  46)
* ibtypes::grep-msg:                     Implicit Buttons.    (line  55)
* ibtypes::hyp-address:                  Implicit Buttons.    (line  59)
* ibtypes::hyp-source:                   Implicit Buttons.    (line  65)
* ibtypes::Info-node:                    Implicit Buttons.    (line  69)
* ibtypes::kbd-key:                      Implicit Buttons.    (line  72)
* ibtypes::klink:                        Implicit Buttons.    (line  77)
* ibtypes::mail-address:                 Implicit Buttons.    (line  82)
* ibtypes::man-apropos:                  Implicit Buttons.    (line  88)
* ibtypes::patch-msg:                    Implicit Buttons.    (line  98)
* ibtypes::pathname:                     Implicit Buttons.    (line 102)
* ibtypes::rfc:                          Implicit Buttons.    (line 112)
* ibtypes::rfc-toc:                      Implicit Buttons.    (line 119)
* ibtypes::text-toc:                     Implicit Buttons.    (line 123)
* ibtypes::www-url:                      Implicit Buttons.    (line 132)
* ibut:at-p:                             Implicit Button Types.
                                                              (line  43)
* Info-directory:                        Installing.          (line  57)
* Info-directory-list:                   Installing.          (line  47)
* interactive:                           Action Type Creation.
                                                              (line  34)
* kfile:find:                            Menu Commands.       (line   9)
* kfile:write:                           Outliner Keys.       (line  13)
* kill-ring:                             Window Configurations.
                                                              (line  48)
* kimport:aug-post-outline:              Inserting and Importing.
                                                              (line  53)
* kimport:file:                          Inserting and Importing.
                                                              (line  26)
* kimport:mode-alist:                    Inserting and Importing.
                                                              (line  16)
* kimport:star-outline:                  Inserting and Importing.
                                                              (line  48)
* kimport:suffix-alist:                  Inserting and Importing.
                                                              (line  16)
* kimport:text:                          Inserting and Importing.
                                                              (line  43)
* klink:create <1>:                      Outliner Keys.       (line  16)
* klink:create:                          Menu Commands.       (line   9)
* kotl-mode:                             Inserting and Importing.
                                                              (line  16)
* kotl-mode-hook:                        Hook Variables.      (line  54)
* kotl-mode:add-cell:                    Outliner Keys.       (line  21)
* kotl-mode:add-child:                   Outliner Keys.       (line  31)
* kotl-mode:add-parent:                  Outliner Keys.       (line  34)
* kotl-mode:append-cell:                 Outliner Keys.       (line  38)
* kotl-mode:back-to-indentation:         Outliner Keys.       (line  43)
* kotl-mode:backward-cell:               Outliner Keys.       (line  47)
* kotl-mode:backward-char:               Outliner Keys.       (line  51)
* kotl-mode:backward-kill-word:          Outliner Keys.       (line  54)
* kotl-mode:backward-sentence:           Outliner Keys.       (line  57)
* kotl-mode:backward-word:               Outliner Keys.       (line  60)
* kotl-mode:beginning-of-buffer:         Outliner Keys.       (line  63)
* kotl-mode:beginning-of-cell:           Outliner Keys.       (line  66)
* kotl-mode:beginning-of-line:           Outliner Keys.       (line  70)
* kotl-mode:beginning-of-tree:           Outliner Keys.       (line  74)
* kotl-mode:center-line:                 Outliner Keys.       (line  78)
* kotl-mode:center-paragraph:            Outliner Keys.       (line  83)
* kotl-mode:copy-after:                  Outliner Keys.       (line  87)
* kotl-mode:copy-before:                 Outliner Keys.       (line  95)
* kotl-mode:copy-to-buffer:              Outliner Keys.       (line 103)
* kotl-mode:copy-to-register:            Outliner Keys.       (line 107)
* kotl-mode:delete-backward-char:        Outliner Keys.       (line 111)
* kotl-mode:delete-blank-lines:          Outliner Keys.       (line 117)
* kotl-mode:delete-char:                 Outliner Keys.       (line 125)
* kotl-mode:delete-indentation:          Outliner Keys.       (line 131)
* kotl-mode:demote-tree:                 Outliner Keys.       (line 136)
* kotl-mode:down-level:                  Outliner Keys.       (line 143)
* kotl-mode:end-of-buffer:               Outliner Keys.       (line 146)
* kotl-mode:end-of-cell:                 Outliner Keys.       (line 149)
* kotl-mode:end-of-line:                 Outliner Keys.       (line 153)
* kotl-mode:end-of-tree:                 Outliner Keys.       (line 156)
* kotl-mode:exchange-cells:              Outliner Keys.       (line 160)
* kotl-mode:fill-cell:                   Outliner Keys.       (line 164)
* kotl-mode:fill-paragraph:              Outliner Keys.       (line 170)
* kotl-mode:fill-tree:                   Outliner Keys.       (line 175)
* kotl-mode:first-sibling:               Outliner Keys.       (line 178)
* kotl-mode:fkey-backward-char:          Outliner Keys.       (line 183)
* kotl-mode:fkey-forward-char:           Outliner Keys.       (line 186)
* kotl-mode:fkey-next-line:              Outliner Keys.       (line 189)
* kotl-mode:fkey-previous-line:          Outliner Keys.       (line 192)
* kotl-mode:forward-cell:                Outliner Keys.       (line 195)
* kotl-mode:forward-char:                Outliner Keys.       (line 199)
* kotl-mode:forward-para:                Outliner Keys.       (line 202)
* kotl-mode:forward-paragraph:           Outliner Keys.       (line 205)
* kotl-mode:forward-sentence:            Outliner Keys.       (line 208)
* kotl-mode:forward-word:                Outliner Keys.       (line 211)
* kotl-mode:goto-cell:                   Outliner Keys.       (line 214)
* kotl-mode:hide-sublevels <1>:          Outliner Keys.       (line 224)
* kotl-mode:hide-sublevels:              Menu Commands.       (line   9)
* kotl-mode:hide-subtree:                Outliner Keys.       (line 229)
* kotl-mode:hide-tree <1>:               Outliner Keys.       (line 233)
* kotl-mode:hide-tree:                   Menu Commands.       (line   9)
* kotl-mode:insert-file:                 Outliner Keys.       (line 237)
* kotl-mode:insert-file-contents:        Inserting and Importing.
                                                              (line  23)
* kotl-mode:insert-register:             Outliner Keys.       (line 243)
* kotl-mode:just-one-space:              Outliner Keys.       (line 250)
* kotl-mode:kcell-help:                  Outliner Keys.       (line 253)
* kotl-mode:kill-contents:               Outliner Keys.       (line 263)
* kotl-mode:kill-line:                   Outliner Keys.       (line 267)
* kotl-mode:kill-region:                 Outliner Keys.       (line 270)
* kotl-mode:kill-ring-save:              Outliner Keys.       (line 280)
* kotl-mode:kill-sentence:               Outliner Keys.       (line 284)
* kotl-mode:kill-tree <1>:               Outliner Keys.       (line 288)
* kotl-mode:kill-tree:                   Menu Commands.       (line   9)
* kotl-mode:kill-word:                   Outliner Keys.       (line 292)
* kotl-mode:last-sibling:                Outliner Keys.       (line 295)
* kotl-mode:mail-tree:                   Outliner Keys.       (line 300)
* kotl-mode:move-after:                  Outliner Keys.       (line 304)
* kotl-mode:move-before:                 Outliner Keys.       (line 314)
* kotl-mode:newline:                     Outliner Keys.       (line 324)
* kotl-mode:next-cell:                   Outliner Keys.       (line 329)
* kotl-mode:next-line:                   Outliner Keys.       (line 332)
* kotl-mode:open-line:                   Outliner Keys.       (line 335)
* kotl-mode:overview <1>:                Outliner Keys.       (line 339)
* kotl-mode:overview:                    Menu Commands.       (line   9)
* kotl-mode:previous-cell:               Outliner Keys.       (line 342)
* kotl-mode:previous-line:               Outliner Keys.       (line 345)
* kotl-mode:promote-tree:                Outliner Keys.       (line 348)
* kotl-mode:refill-flag <1>:             Outliner Keys.       (line 136)
* kotl-mode:refill-flag <2>:             Cell Attributes.     (line  27)
* kotl-mode:refill-flag:                 Filling.             (line  17)
* kotl-mode:scroll-down:                 Outliner Keys.       (line 355)
* kotl-mode:scroll-up:                   Outliner Keys.       (line 359)
* kotl-mode:set-cell-attribute:          Outliner Keys.       (line 363)
* kotl-mode:set-fill-prefix:             Outliner Keys.       (line 369)
* kotl-mode:show-all <1>:                Outliner Keys.       (line 373)
* kotl-mode:show-all:                    Menu Commands.       (line   9)
* kotl-mode:show-subtree:                Outliner Keys.       (line 376)
* kotl-mode:show-tree <1>:               Outliner Keys.       (line 380)
* kotl-mode:show-tree:                   Menu Commands.       (line   9)
* kotl-mode:split-cell:                  Outliner Keys.       (line 383)
* kotl-mode:top-cells <1>:               Outliner Keys.       (line 389)
* kotl-mode:top-cells:                   Menu Commands.       (line   9)
* kotl-mode:transpose-cells:             Outliner Keys.       (line 392)
* kotl-mode:transpose-chars:             Outliner Keys.       (line 399)
* kotl-mode:transpose-lines:             Outliner Keys.       (line 406)
* kotl-mode:transpose-words:             Outliner Keys.       (line 413)
* kotl-mode:up-level:                    Outliner Keys.       (line 420)
* kotl-mode:yank:                        Outliner Keys.       (line 423)
* kotl-mode:yank-pop:                    Outliner Keys.       (line 431)
* kotl-mode:zap-to-char:                 Outliner Keys.       (line 445)
* kview:default-label-separator:         Autonumbering.       (line  56)
* kview:default-label-type:              View Specs.          (line  49)
* kview:set-label-type:                  Outliner Keys.       (line 449)
* kvspec:activate <1>:                   Outliner Keys.       (line 454)
* kvspec:activate:                       Menu Commands.       (line   9)
* kvspec:string:                         View Specs.          (line   6)
* kvspec:toggle-blank-lines <1>:         Outliner Keys.       (line 460)
* kvspec:toggle-blank-lines:             Menu Commands.       (line   9)
* mail:                                  Buttons in Mail.     (line   6)
* mail-yank-original:                    Buttons in Mail.     (line  21)
* rolo-add:                              Rolo Menu.           (line  10)
* rolo-display-matches:                  Rolo Menu.           (line  10)
* rolo-edit:                             Rolo Menu.           (line  10)
* rolo-email-format:                     Rolo Settings.       (line  19)
* rolo-entry-regexp:                     Rolo Settings.       (line  35)
* rolo-fgrep:                            Rolo Menu.           (line  10)
* rolo-file-list:                        Rolo Settings.       (line  26)
* rolo-grep:                             Rolo Menu.           (line  10)
* rolo-hdr-regexp:                       Rolo Settings.       (line  38)
* rolo-highlight-face:                   Rolo Settings.       (line   6)
* rolo-kill:                             Rolo Menu.           (line  10)
* rolo-kill-buffers-after-use:           Rolo Settings.       (line  10)
* rolo-mail-to:                          Rolo Menu.           (line  10)
* rolo-save-buffers-after-use:           Rolo Settings.       (line  15)
* rolo-sort:                             Rolo Menu.           (line  10)
* rolo-word:                             Rolo Menu.           (line  10)
* rolo-yank:                             Rolo Menu.           (line  10)
* run-hooks:                             Glossary.            (line 160)
* SITE-PRELOADS, environment variable:   Building.            (line  16)
* smail:comment:                         Buttons in Mail.     (line  47)
* smart-scroll-proportional <1>:         Smart Keyboard Keys. (line  22)
* smart-scroll-proportional:             Glossary.            (line 269)
* wconfig-add-by-name:                   Window Configurations.
                                                              (line  29)
* wconfig-delete-by-name:                Window Configurations.
                                                              (line  29)
* wconfig-delete-pop:                    Window Configurations.
                                                              (line  29)
* wconfig-restore-by-name:               Window Configurations.
                                                              (line  29)
* wconfig-ring-max:                      Window Configurations.
                                                              (line  71)
* wconfig-ring-save:                     Window Configurations.
                                                              (line  29)
* wconfig-yank-pop:                      Window Configurations.
                                                              (line  29)
* write-file-hooks:                      Hook Variables.      (line  79)
* wrolo-display-hook:                    Hook Variables.      (line  58)
* wrolo-mode-hook:                       Hook Variables.      (line  61)
* wrolo-yank-reformat-function:          Hook Variables.      (line  65)


File: hyperbole.info,  Node: Concept Index,  Prev: Code and File Index,  Up: Top

Concept Index
*************

 [index ]
* Menu:

* <> delimiters:                         Links.               (line   6)
* <@ klink>:                             Links.               (line  30)
* <|viewspec>:                           View Specs.          (line   6)
* action <1>:                            Glossary.            (line  10)
* action:                                Action Types.        (line   6)
* Action Key <1>:                        Glossary.            (line  15)
* Action Key:                            Smart Keys.          (line   6)
* Action Key drag:                       By Dragging.         (line   6)
* Action Key, cell argument:             Relocating and Copying.
                                                              (line  21)
* Action Key, hide or show cell:         Hiding and Showing.  (line  43)
* Action Key, klink:                     Links.               (line  13)
* Action Key, web browsing:              Implicit Buttons.    (line 132)
* action type <1>:                       Glossary.            (line  18)
* action type:                           Action Types.        (line   6)
* action type, creation:                 Action Type Creation.
                                                              (line  10)
* activation <1>:                        Glossary.            (line  25)
* activation:                            Smart Keys.          (line  35)
* actype, link-to-mail:                  Buttons in Mail.     (line  62)
* actypes, list of:                      Action Types.        (line  12)
* address:                               Implicit Buttons.    (line  82)
* alpha labels:                          Autonumbering.       (line  17)
* ange-ftp <1>:                          Glossary.            (line  29)
* ange-ftp:                              Implicit Buttons.    (line 102)
* anonymous ftp <1>:                     Obtaining.           (line   6)
* anonymous ftp:                         Top.                 (line  26)
* API:                                   Embedding Hyperbole. (line   9)
* appending to a cell:                   Splitting and Appending.
                                                              (line  16)
* argument:                              Glossary.            (line  36)
* argument entry:                        Entering Arguments.  (line   6)
* argument, Info node:                   Action Type Creation.
                                                              (line  44)
* argument, kcell:                       Action Type Creation.
                                                              (line  47)
* argument, koutline:                    Action Type Creation.
                                                              (line  47)
* argument, mail message:                Action Type Creation.
                                                              (line  51)
* argument, reading:                     Action Type Creation.
                                                              (line  61)
* argument, use:                         Action Types.        (line   6)
* argument, view spec:                   Action Type Creation.
                                                              (line  56)
* Assist Key <1>:                        Glossary.            (line  40)
* Assist Key:                            Smart Keys.          (line   6)
* Assist Key, listing attributes:        Cell Attributes.     (line  33)
* attribute:                             Cell Attributes.     (line   6)
* attribute, adding:                     Cell Attributes.     (line  22)
* attribute, modifying:                  Cell Attributes.     (line  22)
* attribute, no-fill <1>:                Cell Attributes.     (line  27)
* attribute, no-fill <2>:                Splitting and Appending.
                                                              (line  16)
* attribute, no-fill:                    Filling.             (line  17)
* attribute, removing:                   Cell Attributes.     (line  22)
* attributes:                            Glossary.            (line  43)
* Augment <1>:                           Glossary.            (line  47)
* Augment:                               Outliner History.    (line   6)
* Augment outline:                       Inserting and Importing.
                                                              (line  53)
* autoloading Hyperbole:                 Installing.          (line  16)
* autonumber <1>:                        Autonumbering.       (line   6)
* autonumber:                            Outliner.            (line   6)
* bibliography:                          Implicit Buttons.    (line  24)
* blank lines, toggle:                   View Specs.          (line  33)
* breakpoint:                            Implicit Buttons.    (line  50)
* buffer menu:                           Smart Keyboard Keys. (line 350)
* bug-hyperbole mail list:               Mail Lists.          (line  59)
* building Hyperbole:                    Building.            (line   6)
* button <1>:                            Glossary.            (line  60)
* button:                                Hyperbole Overview.  (line   6)
* button activation <1>:                 Glossary.            (line  72)
* button activation:                     Smart Keys.          (line  35)
* button attribute:                      Explicit Buttons.    (line  14)
* button attributes <1>:                 Glossary.            (line  75)
* button attributes:                     Operational and Storage Formats.
                                                              (line   6)
* button category:                       Hyperbole Overview.  (line  11)
* button click:                          Smart Keyboard Keys. (line  36)
* button data <1>:                       Glossary.            (line  78)
* button data:                           Explicit Buttons.    (line  14)
* button data saving:                    Hook Variables.      (line  79)
* button demo:                           Top.                 (line  79)
* button emphasis:                       Button Colors.       (line  16)
* button file, directory:                Button Files.        (line  13)
* button file, HYPB:                     Menus.               (line  34)
* button file, local:                    Glossary.            (line  82)
* button file, personal <1>:             Glossary.            (line  87)
* button file, personal:                 Button Files.        (line  13)
* button files:                          Button Files.        (line   6)
* button flashing:                       Button Colors.       (line   6)
* button help:                           Smart Keys.          (line  35)
* button highlighting <1>:               Hook Variables.      (line  74)
* button highlighting:                   Button Colors.       (line   6)
* button highlighting, forcing:          Button Colors.       (line  22)
* button instance:                       By Menu.             (line  25)
* button key <1>:                        Glossary.            (line  91)
* button key:                            Button Label Normalization.
                                                              (line   6)
* button label <1>:                      Glossary.            (line  94)
* button label <2>:                      Button Label Normalization.
                                                              (line   6)
* button label <3>:                      Global Buttons.      (line   6)
* button label:                          Explicit Buttons.    (line   6)
* button label overlap:                  Button Type Precedence.
                                                              (line   6)
* button precedence:                     Button Type Precedence.
                                                              (line   6)
* button selection:                      Glossary.            (line 106)
* button, creation:                      By Dragging.         (line   6)
* button, deleting:                      Deletion.            (line   6)
* button, explicit <1>:                  Explicit Buttons.    (line   6)
* button, explicit:                      Hyperbole Overview.  (line  11)
* button, global <1>:                    Global Buttons.      (line   6)
* button, global:                        Hyperbole Overview.  (line  11)
* button, help:                          Location.            (line   6)
* button, implicit <1>:                  Implicit Buttons.    (line   6)
* button, implicit:                      Hyperbole Overview.  (line  11)
* button, mailing:                       Buttons in Mail.     (line  12)
* button, modifying:                     Modification.        (line   6)
* button, moving:                        Explicit Buttons.    (line  22)
* button, multiple lines:                Button Label Normalization.
                                                              (line  25)
* button, posting <1>:                   Buttons in News.     (line   6)
* button, posting:                       Buttons in Mail.     (line  12)
* button, renaming:                      Renaming.            (line   6)
* button, searching:                     Location.            (line  16)
* button, split across lines:            Button Label Normalization.
                                                              (line  25)
* button, summarizing:                   Location.            (line   6)
* byte compiler error:                   Implicit Buttons.    (line  46)
* category:                              Glossary.            (line 110)
* cell:                                  Glossary.            (line 114)
* cell, adding:                          Adding and Killing.  (line   6)
* cell, appending:                       Splitting and Appending.
                                                              (line  16)
* cell, attribute:                       Cell Attributes.     (line   6)
* cell, collapse:                        Hiding and Showing.  (line  43)
* cell, creating:                        Adding and Killing.  (line   6)
* cell, creation time:                   Cell Attributes.     (line  17)
* cell, exchanging:                      Transposing.         (line  10)
* cell, expand:                          Hiding and Showing.  (line  43)
* cell, filling:                         Filling.             (line  11)
* cell, hide subtree:                    Hiding and Showing.  (line  26)
* cell, hiding levels:                   View Specs.          (line  46)
* cell, idstamp 0 <1>:                   Idstamps.            (line  16)
* cell, idstamp 0:                       Creating Outlines.   (line  10)
* cell, killing:                         Adding and Killing.  (line  14)
* cell, label separator:                 Autonumbering.       (line  44)
* cell, mark and point:                  Transposing.         (line  17)
* cell, no-fill attribute <1>:           Cell Attributes.     (line  27)
* cell, no-fill attribute <2>:           Splitting and Appending.
                                                              (line  16)
* cell, no-fill attribute:               Filling.             (line  17)
* cell, selection:                       Editing.             (line  19)
* cell, show all:                        Hiding and Showing.  (line  19)
* cell, show levels:                     Hiding and Showing.  (line  20)
* cell, show subtree:                    Hiding and Showing.  (line  27)
* cell, splitting:                       Splitting and Appending.
                                                              (line   6)
* cell, top-level <1>:                   Idstamps.            (line  16)
* cell, top-level:                       Creating Outlines.   (line  10)
* cell, transposing:                     Transposing.         (line  10)
* cell, yanking contents:                Adding and Killing.  (line  14)
* changing the view spec:                View Specs.          (line  24)
* children:                              Glossary.            (line 117)
* class:                                 Glossary.            (line 121)
* click, buffer menu:                    Smart Keyboard Keys. (line 350)
* click, button:                         Smart Keyboard Keys. (line  36)
* click, dired:                          Smart Keyboard Keys. (line 369)
* click, end of line:                    Smart Keyboard Keys. (line  22)
* click, GNUS:                           Smart Keyboard Keys. (line 313)
* click, Info:                           Smart Keyboard Keys. (line 264)
* click, tar:                            Smart Keyboard Keys. (line 386)
* click, world-wide web:                 Smart Keyboard Keys. (line 406)
* click, wrolo matches:                  Smart Keyboard Keys. (line 418)
* collaboration:                         Outliner History.    (line  11)
* collapse lines:                        View Specs.          (line  39)
* collapsing:                            Hiding and Showing.  (line   6)
* compiler error:                        Implicit Buttons.    (line  46)
* compiling Lisp:                        Building.            (line  10)
* completion <1>:                        Entering Arguments.  (line  23)
* completion:                            Implicit Buttons.    (line  30)
* configuration <1>:                     Configuring.         (line   6)
* configuration:                         Installing.          (line   6)
* context <1>:                           Glossary.            (line 126)
* context:                               Implicit Buttons.    (line  14)
* context sensitive help:                Smart Keys.          (line 139)
* create-time attribute:                 Cell Attributes.     (line  17)
* creator attribute:                     Cell Attributes.     (line  14)
* credits:                               Top.                 (line  26)
* cross referencing:                     Outliner History.    (line  16)
* customization, init:                   Installation.        (line  10)
* cutoff lines:                          View Specs.          (line  39)
* dbx:                                   Implicit Buttons.    (line  50)
* default label type:                    View Specs.          (line  49)
* demonstration:                         Top.                 (line  79)
* demotion:                              Relocating and Copying.
                                                              (line   6)
* depress, modeline:                     Smart Mouse Keys.    (line  34)
* diagonal drag:                         Smart Mouse Keys.    (line  67)
* digital signature:                     Glossary.            (line  47)
* direct selection:                      Entering Arguments.  (line   6)
* dired browsing:                        Smart Keyboard Keys. (line 369)
* display function:                      Internal Viewers.    (line   6)
* distributed collaboration:             Outliner History.    (line  11)
* document identifier:                   Implicit Buttons.    (line  39)
* double click:                          Entering Arguments.  (line   6)
* downloading Hyperbole:                 Obtaining.           (line  10)
* drag:                                  By Dragging.         (line   6)
* drag, between windows:                 Smart Mouse Keys.    (line  17)
* drag, diagonal:                        Smart Mouse Keys.    (line  67)
* drag, horizontal:                      Smart Mouse Keys.    (line  25)
* drag, side edge:                       Smart Mouse Keys.    (line  12)
* drag, vertical:                        Smart Mouse Keys.    (line  61)
* e-mail:                                Mail Lists.          (line  11)
* e-mail address <1>:                    Cell Attributes.     (line  14)
* e-mail address:                        Implicit Buttons.    (line  82)
* e-mail, effective communication:       Mail Lists.          (line  37)
* effective communication:               Mail Lists.          (line  37)
* efs <1>:                               Glossary.            (line 137)
* efs:                                   Implicit Buttons.    (line 102)
* ellipses:                              View Specs.          (line  43)
* Emacs 19 <1>:                          Menus.               (line   6)
* Emacs 19:                              Top.                 (line  37)
* Emacs 19 support:                      Button Colors.       (line   6)
* Emacs Lisp:                            Top.                 (line  37)
* Emacs Lisp compiler error:             Implicit Buttons.    (line  46)
* Emacs Lisp variables:                  Link Variable Substitution.
                                                              (line   6)
* emacs outline:                         Inserting and Importing.
                                                              (line  48)
* Emacs version:                         Mail Lists.          (line  45)
* end of line click:                     Smart Keyboard Keys. (line  22)
* Engelbart <1>:                         Glossary.            (line  47)
* Engelbart:                             Outliner History.    (line   6)
* environment:                           Glossary.            (line 134)
* environment variables:                 Link Variable Substitution.
                                                              (line   6)
* Epoch:                                 Top.                 (line  37)
* Epoch support:                         Button Colors.       (line   6)
* exchanging cells:                      Transposing.         (line  10)
* expanding:                             Hiding and Showing.  (line   6)
* explicit button <1>:                   Glossary.            (line 141)
* explicit button <2>:                   Explicit Buttons.    (line   6)
* explicit button:                       Hyperbole Overview.  (line  11)
* explicit button, creation <1>:         Programmatic Button Creation.
                                                              (line   6)
* explicit button, creation:             By Dragging.         (line   6)
* explicit button, deleting:             Deletion.            (line   6)
* explicit button, formats:              Operational and Storage Formats.
                                                              (line   6)
* explicit button, modifying:            Modification.        (line   6)
* explicit button, renaming:             Renaming.            (line   6)
* explicit button, searching:            Location.            (line  16)
* explicit button, storage:              Operational and Storage Formats.
                                                              (line   6)
* explicit button, summarizing:          Location.            (line   6)
* exporting an outline:                  Relocating and Copying.
                                                              (line  69)
* external klink:                        Links.               (line  41)
* external program:                      External Viewers.    (line   6)
* external viewer:                       External Viewers.    (line   6)
* extracting from tar files:             Smart Keyboard Keys. (line 386)
* file display function:                 Internal Viewers.    (line   6)
* file, importing:                       Inserting and Importing.
                                                              (line  16)
* filename:                              Implicit Buttons.    (line 102)
* fill prefix:                           Button Label Normalization.
                                                              (line  25)
* filling:                               Filling.             (line  11)
* ftp <1>:                               Glossary.            (line  29)
* ftp:                                   Obtaining.           (line   6)
* game, gomoku:                          Smart Keyboard Keys. (line 412)
* gdb:                                   Implicit Buttons.    (line  50)
* global button <1>:                     Glossary.            (line 146)
* global button <2>:                     Button Files.        (line  18)
* global button <3>:                     Global Buttons.      (line   6)
* global button:                         Hyperbole Overview.  (line  11)
* global button file:                    Glossary.            (line 157)
* global button, modify:                 Questions and Answers.
                                                              (line  38)
* GNU Emacs:                             Top.                 (line  79)
* GNUS <1>:                              Buttons in News.     (line   6)
* GNUS:                                  Buttons in Mail.     (line  12)
* GNUS browsing:                         Smart Keyboard Keys. (line 313)
* gomoku:                                Smart Keyboard Keys. (line 412)
* grep:                                  Implicit Buttons.    (line  55)
* groupware:                             Glossary.            (line  47)
* gunzip:                                Obtaining.           (line  56)
* gzcat:                                 Obtaining.           (line  56)
* help, menu items:                      Menus.               (line  75)
* help, Smart Key:                       Smart Keys.          (line 139)
* hide levels:                           View Specs.          (line  46)
* hide lines:                            View Specs.          (line  39)
* hide subtree:                          Hiding and Showing.  (line  26)
* hide tree:                             Hiding and Showing.  (line  13)
* hiding:                                Hiding and Showing.  (line   6)
* history:                               Menus.               (line  51)
* hook variable:                         Glossary.            (line 160)
* hook variables:                        Hook Variables.      (line   6)
* horizontal drag:                       Smart Mouse Keys.    (line  25)
* Hyperbole <1>:                         Glossary.            (line 165)
* Hyperbole:                             Top.                 (line  37)
* Hyperbole API:                         Embedding Hyperbole. (line   9)
* Hyperbole applications:                Hyperbole Overview.  (line  73)
* Hyperbole data model:                  Explicit Buttons.    (line  33)
* Hyperbole environment:                 Glossary.            (line 171)
* Hyperbole features:                    Hyperbole Overview.  (line  49)
* Hyperbole help:                        Smart Keys.          (line 131)
* Hyperbole mail list:                   Implicit Buttons.    (line  59)
* hyperbole mail list:                   Mail Lists.          (line  32)
* Hyperbole main menu:                   Installing.          (line  70)
* Hyperbole manual:                      Installing.          (line  42)
* Hyperbole report:                      Implicit Buttons.    (line  65)
* Hyperbole types:                       Creating Types.      (line  15)
* Hyperbole version <1>:                 Suggestion or Bug Reporting.
                                                              (line   9)
* Hyperbole version:                     Mail Lists.          (line  45)
* Hyperbole, autoloading:                Installing.          (line  16)
* Hyperbole, building:                   Building.            (line   6)
* Hyperbole, embedding:                  Embedding Hyperbole. (line   9)
* Hyperbole, initializing:               Installing.          (line  11)
* Hyperbole, loading:                    Installing.          (line  25)
* Hyperbole, obtaining <1>:              Obtaining.           (line  10)
* Hyperbole, obtaining:                  Top.                 (line  26)
* Hyperbole, starting:                   Installing.          (line  70)
* Hyperbole, system encapsulation:       Encapsulating Systems.
                                                              (line   6)
* HYPERBOLE-DIR:                         Building.            (line  20)
* hyperlink:                             Links.               (line   6)
* hyperlink anchor:                      Outliner.            (line   6)
* hypertext <1>:                         Glossary.            (line  47)
* hypertext:                             Top.                 (line  37)
* ibtype:                                Implicit Button Types.
                                                              (line   6)
* ibtype, actype:                        Implicit Button Types.
                                                              (line  13)
* ibtype, argument:                      Implicit Button Types.
                                                              (line  13)
* ibtype, evaluation order:              Button Type Precedence.
                                                              (line  12)
* ibtype, help:                          Implicit Button Types.
                                                              (line  43)
* ibtype, predicate:                     Implicit Button Types.
                                                              (line  13)
* ibtype, return val:                    Implicit Button Types.
                                                              (line  13)
* ibtypes, list of:                      Implicit Buttons.    (line  20)
* idea structuring:                      Outliner History.    (line  16)
* idstamp <1>:                           Idstamps.            (line   6)
* idstamp:                               Outliner.            (line   6)
* idstamp 0:                             Idstamps.            (line  16)
* idstamp attribute:                     Cell Attributes.     (line  10)
* idstamp counter:                       Idstamps.            (line  11)
* implicit button <1>:                   Glossary.            (line 185)
* implicit button <2>:                   Implicit Buttons.    (line   6)
* implicit button:                       Hyperbole Overview.  (line  11)
* implicit button type <1>:              Glossary.            (line 189)
* implicit button type:                  Implicit Button Types.
                                                              (line   6)
* importation:                           Inserting and Importing.
                                                              (line   6)
* importing a file:                      Inserting and Importing.
                                                              (line  16)
* Info browsing:                         Smart Keyboard Keys. (line 264)
* Info manual:                           Installing.          (line  44)
* Info node:                             Implicit Buttons.    (line  69)
* InfoDock <1>:                          Menus.               (line   6)
* InfoDock:                              Obtaining.           (line   6)
* InfoDock, obtaining:                   Top.                 (line  26)
* initialization file:                   Autonumbering.       (line  52)
* initializing Hyperbole:                Installing.          (line  11)
* insertion:                             Inserting and Importing.
                                                              (line   6)
* installation <1>:                      Installing.          (line  11)
* installation:                          Installation.        (line   6)
* instance number <1>:                   Glossary.            (line 196)
* instance number:                       By Menu.             (line  25)
* interactive cmd char, +I:              Action Type Creation.
                                                              (line  44)
* interactive cmd char, +K:              Action Type Creation.
                                                              (line  47)
* interactive cmd char, +M:              Action Type Creation.
                                                              (line  51)
* interactive cmd char, +V:              Action Type Creation.
                                                              (line  56)
* interactive computing:                 Glossary.            (line  47)
* interactive form:                      Action Type Creation.
                                                              (line  34)
* internal klink:                        Links.               (line  30)
* internal viewer:                       Internal Viewers.    (line   6)
* Internet RFC:                          Implicit Buttons.    (line 112)
* invoking Hyperbole:                    Installing.          (line  70)
* joining a mail list:                   Mail Lists.          (line  18)
* kcell:                                 Glossary.            (line 212)
* kcell link:                            Implicit Buttons.    (line  77)
* key binding, smart keys:               Smart Keys.          (line  27)
* key sequence:                          Implicit Buttons.    (line  72)
* klink <1>:                             Links.               (line   6)
* klink:                                 Implicit Buttons.    (line  77)
* klink referent:                        Links.               (line  13)
* klink, activating:                     Links.               (line  13)
* klink, external:                       Links.               (line  41)
* klink, formats:                        Links.               (line  28)
* klink, inserting:                      Links.               (line  18)
* klink, internal:                       Links.               (line  30)
* klink, view spec:                      Links.               (line  49)
* knowledge transfer:                    Outliner History.    (line  16)
* koutline:                              Glossary.            (line 203)
* koutline link:                         Implicit Buttons.    (line  77)
* koutline mode:                         Inserting and Importing.
                                                              (line  16)
* Koutliner:                             Glossary.            (line 207)
* Koutliner commands:                    Menu Commands.       (line   9)
* label separator, changing:             Autonumbering.       (line  44)
* label separator, default:              Autonumbering.       (line  56)
* label type:                            View Specs.          (line  49)
* label type, alpha <1>:                 View Specs.          (line  54)
* label type, alpha:                     Autonumbering.       (line  17)
* label type, asterisk:                  View Specs.          (line  64)
* label type, changing:                  Autonumbering.       (line  34)
* label type, idstamps:                  View Specs.          (line  51)
* label type, legal <1>:                 View Specs.          (line  61)
* label type, legal:                     Autonumbering.       (line  17)
* label type, no labels:                 View Specs.          (line  68)
* label type, partial alpha:             View Specs.          (line  57)
* label type, star:                      View Specs.          (line  64)
* legal labels:                          Autonumbering.       (line  17)
* level <1>:                             View Specs.          (line  46)
* level:                                 Hiding and Showing.  (line  20)
* link <1>:                              Glossary.            (line 218)
* link:                                  Links.               (line   6)
* link, creation <1>:                    By Menu.             (line  33)
* link, creation:                        By Dragging.         (line   6)
* link, display function:                Internal Viewers.    (line   6)
* link, pathname:                        Implicit Buttons.    (line 102)
* link, viewer program:                  External Viewers.    (line   6)
* linking, in-place:                     Explicit Buttons.    (line  33)
* Lisp compilation:                      Building.            (line  10)
* Lisp variables:                        Link Variable Substitution.
                                                              (line   6)
* listing attributes:                    Cell Attributes.     (line  33)
* loading Hyperbole:                     Installing.          (line  25)
* local button file:                     Glossary.            (line 224)
* Lucid Emacs:                           Top.                 (line  37)
* mail address:                          Cell Attributes.     (line  14)
* mail comment:                          Buttons in Mail.     (line  47)
* mail hooks:                            Hook Variables.      (line  84)
* mail inclusion:                        Buttons in Mail.     (line  21)
* mail list requests:                    Mail Lists.          (line  18)
* mail lists:                            Mail Lists.          (line  11)
* mail reader:                           Buttons in Mail.     (line  12)
* mailer initialization:                 Buttons in Mail.     (line  12)
* mailing an outline:                    Relocating and Copying.
                                                              (line  69)
* mailing buttons:                       Buttons in Mail.     (line  12)
* man page references:                   Smart Keyboard Keys. (line 398)
* manual, generating Postscript:         Building.            (line  34)
* margin:                                Filling.             (line  11)
* menu help:                             Menus.               (line  75)
* menu use:                              Menus.               (line   6)
* menu, Act:                             Menus.               (line  29)
* menu, ButFile:                         Menus.               (line  34)
* menu, Doc:                             Menus.               (line  43)
* menu, EBut:                            Menus.               (line  40)
* menu, Global Buttons:                  Menus.               (line  47)
* menu, History:                         Menus.               (line  51)
* menu, Implicit Buttons:                Menus.               (line  54)
* menu, Message:                         Menus.               (line  57)
* menu, Outline <1>:                     Menu Commands.       (line   9)
* menu, Outline:                         Outliner.            (line  18)
* menu, Outline/Example:                 Outliner.            (line  27)
* menu, Outliner:                        Menus.               (line  62)
* menu, Rolodex:                         Menus.               (line  66)
* menu, top level:                       Menus.               (line  19)
* menu, Types:                           Menus.               (line  43)
* menu, Window Configurations:           Menus.               (line  70)
* menu, Windows:                         Menus.               (line  70)
* menubar, Hyperbole menu:               Menus.               (line   6)
* MH-e:                                  Buttons in Mail.     (line  12)
* minibuffer menu:                       Glossary.            (line 231)
* minibuffer menus:                      Menus.               (line  13)
* minibuffer window:                     Glossary.            (line 227)
* modeline depress:                      Smart Mouse Keys.    (line  34)
* modeline, view spec:                   View Specs.          (line   6)
* mouse:                                 Glossary.            (line  47)
* mouse button:                          Glossary.            (line 237)
* mouse key bindings:                    Questions and Answers.
                                                              (line   6)
* mouse key toggle:                      Smart Keys.          (line 154)
* mouse support:                         Smart Keys.          (line   6)
* mouse, moving trees:                   Relocating and Copying.
                                                              (line  58)
* moving buttons:                        Explicit Buttons.    (line  22)
* news:                                  Buttons in Mail.     (line  12)
* news comment:                          Buttons in News.     (line  28)
* news hooks:                            Hook Variables.      (line  84)
* news reader/poster:                    Buttons in News.     (line   6)
* NLS <1>:                               Glossary.            (line  47)
* NLS:                                   Outliner History.    (line   6)
* no-fill attribute:                     Cell Attributes.     (line  27)
* node:                                  Glossary.            (line 242)
* normalized label:                      Button Label Normalization.
                                                              (line   6)
* obtaining Hyperbole:                   Obtaining.           (line  10)
* online library:                        Implicit Buttons.    (line  39)
* outline:                               Glossary.            (line 245)
* outline file suffix:                   Creating Outlines.   (line   6)
* outline mode:                          Inserting and Importing.
                                                              (line  16)
* outline processor:                     Glossary.            (line  47)
* outline structure:                     Autonumbering.       (line  13)
* outline, all cells:                    Hiding and Showing.  (line  19)
* outline, attribute list:               Cell Attributes.     (line  33)
* outline, conversion:                   Inserting and Importing.
                                                              (line  16)
* outline, creating:                     Creating Outlines.   (line   6)
* outline, exporting:                    Relocating and Copying.
                                                              (line  69)
* outline, filling:                      Filling.             (line   6)
* outline, foreign file:                 Inserting and Importing.
                                                              (line   6)
* outline, hiding:                       Hiding and Showing.  (line   6)
* outline, importing into:               Inserting and Importing.
                                                              (line   6)
* outline, inserting into:               Inserting and Importing.
                                                              (line   6)
* outline, label separator:              Autonumbering.       (line  44)
* outline, label type:                   Autonumbering.       (line  17)
* outline, mailing:                      Relocating and Copying.
                                                              (line  69)
* outline, motion:                       Moving Around.       (line   6)
* outline, overview:                     Hiding and Showing.  (line  34)
* outline, show levels:                  Hiding and Showing.  (line  20)
* outline, showing:                      Hiding and Showing.  (line   6)
* outline, top-level:                    Hiding and Showing.  (line  37)
* outline, view specs:                   View Specs.          (line  16)
* outline, viewing:                      Viewing.             (line   6)
* outliner:                              Outliner.            (line   6)
* outliner commands:                     Menu Commands.       (line   9)
* outliner keys:                         Outliner Keys.       (line   6)
* overview:                              Hiding and Showing.  (line  34)
* paragraph, filling:                    Filling.             (line  11)
* parent:                                Glossary.            (line 248)
* patch output:                          Implicit Buttons.    (line  98)
* pathname:                              Implicit Buttons.    (line 102)
* permanent identifier <1>:              Idstamps.            (line   6)
* permanent identifier:                  Outliner.            (line   6)
* PIEmail:                               Buttons in Mail.     (line  12)
* pipe character:                        View Specs.          (line   6)
* posting buttons:                       Buttons in Mail.     (line  12)
* posting news:                          Buttons in News.     (line   6)
* Postscript:                            Building.            (line  34)
* predecessor:                           Glossary.            (line 251)
* predicate:                             Glossary.            (line 254)
* programming interface:                 Embedding Hyperbole. (line   9)
* promotion:                             Relocating and Copying.
                                                              (line   6)
* proportional scrolling <1>:            Smart Keyboard Keys. (line  22)
* proportional scrolling:                Glossary.            (line 269)
* reference:                             Implicit Buttons.    (line  24)
* referent:                              Glossary.            (line 258)
* refilling:                             Filling.             (line  17)
* relative autonumber:                   Outliner.            (line   6)
* relative identifier:                   Autonumbering.       (line   6)
* remote path:                           Implicit Buttons.    (line 102)
* Request For Comment:                   Implicit Buttons.    (line 112)
* restoring windows:                     Window Configurations.
                                                              (line   6)
* RFC:                                   Implicit Buttons.    (line 112)
* RMAIL:                                 Buttons in Mail.     (line  12)
* rolo, buttons in:                      Rolodex.             (line   9)
* rolodex <1>:                           Glossary.            (line 261)
* rolodex:                               Rolodex.             (line   6)
* rolodex address:                       Implicit Buttons.    (line  82)
* rolodex commands:                      Rolo Menu.           (line  10)
* rolodex entry:                         Rolo Concepts.       (line   6)
* rolodex file:                          Rolo Concepts.       (line   6)
* rolodex keys:                          Rolo Keys.           (line   9)
* rolodex menu:                          Rolo Menu.           (line   6)
* rolodex, editing an entry:             Rolo Keys.           (line   6)
* rolodex, extending a match:            Rolo Keys.           (line  21)
* rolodex, finding matches:              Rolo Keys.           (line  14)
* rolodex, highlighting matches <1>:     Rolo Settings.       (line   6)
* rolodex, highlighting matches:         Rolo Keys.           (line  14)
* rolodex, interactive searching:        Rolo Keys.           (line  21)
* rolodex, moving through matches:       Rolo Keys.           (line  14)
* rolodex, moving to entries:            Rolo Keys.           (line  37)
* rolodex, outlining:                    Rolo Keys.           (line  27)
* rolodex, personal:                     Rolo Settings.       (line  26)
* rolodex, quitting:                     Rolo Keys.           (line  66)
* root cell <1>:                         Glossary.            (line 265)
* root cell <2>:                         Idstamps.            (line  16)
* root cell:                             Creating Outlines.   (line  10)
* saving window configurations:          Window Configurations.
                                                              (line   6)
* scrolling <1>:                         Smart Keyboard Keys. (line  22)
* scrolling:                             Glossary.            (line 269)
* setting the view spec:                 View Specs.          (line  24)
* show subtree:                          Hiding and Showing.  (line  27)
* show tree:                             Hiding and Showing.  (line  14)
* showing:                               Hiding and Showing.  (line   6)
* side drag:                             Smart Mouse Keys.    (line  12)
* site initialization:                   Installing.          (line  11)
* Smart Key <1>:                         Questions and Answers.
                                                              (line   6)
* Smart Key <2>:                         Glossary.            (line 269)
* Smart Key:                             Smart Keys.          (line   6)
* smart key commands:                    Smart Keys.          (line  27)
* Smart Key help:                        Smart Keys.          (line 139)
* Smart Key operation:                   Smart Keys.          (line  40)
* Smart Key toggle:                      Smart Keys.          (line 154)
* Smart Keyboard Keys:                   Smart Keyboard Keys. (line   6)
* Smart Mouse Key drag:                  Modification.        (line   6)
* Smart Mouse Keys:                      Smart Mouse Keys.    (line   6)
* source buffer:                         Glossary.            (line 292)
* source file:                           Glossary.            (line 292)
* source line:                           Implicit Buttons.    (line  50)
* splitting a cell:                      Splitting and Appending.
                                                              (line   6)
* stack frame:                           Implicit Buttons.    (line  50)
* star outline:                          Inserting and Importing.
                                                              (line  48)
* starting Hyperbole:                    Installing.          (line  70)
* storage manager:                       Operational and Storage Formats.
                                                              (line   6)
* submenus:                              Menus.               (line  75)
* subscribing to a mail list:            Mail Lists.          (line  18)
* subtree:                               Glossary.            (line 295)
* subtree, hide:                         Hiding and Showing.  (line  26)
* subtree, show:                         Hiding and Showing.  (line  27)
* successor:                             Glossary.            (line 299)
* system encapsulation <1>:              Glossary.            (line 302)
* system encapsulation:                  Encapsulating Systems.
                                                              (line   6)
* table of contents <1>:                 Action Types.        (line 133)
* table of contents:                     Implicit Buttons.    (line 119)
* tar archive:                           Obtaining.           (line  56)
* tar archive browsing:                  Smart Keyboard Keys. (line 386)
* terminal use:                          Hyperbole Overview.  (line  41)
* Texinfo manual:                        Installing.          (line  44)
* text file:                             Inserting and Importing.
                                                              (line  43)
* toc action type:                       Action Types.        (line 133)
* toc implicit button type:              Implicit Buttons.    (line 123)
* toggling blank lines:                  View Specs.          (line  33)
* top-level cell <1>:                    Idstamps.            (line  16)
* top-level cell:                        Creating Outlines.   (line  10)
* top-level view:                        Hiding and Showing.  (line  37)
* transposing cells:                     Transposing.         (line  10)
* tree:                                  Glossary.            (line 308)
* tree, copying:                         Relocating and Copying.
                                                              (line  21)
* tree, demoting:                        Relocating and Copying.
                                                              (line   6)
* tree, exporting:                       Relocating and Copying.
                                                              (line  69)
* tree, filling:                         Filling.             (line  11)
* tree, hide subtree:                    Hiding and Showing.  (line  26)
* tree, killing:                         Adding and Killing.  (line  14)
* tree, mailing:                         Relocating and Copying.
                                                              (line  69)
* tree, moving:                          Relocating and Copying.
                                                              (line  21)
* tree, promoting:                       Relocating and Copying.
                                                              (line   6)
* tree, show:                            Hiding and Showing.  (line  13)
* tree, show subtree:                    Hiding and Showing.  (line  27)
* type definition:                       Creating Types.      (line   6)
* type redefinition <1>:                 Creating Types.      (line   6)
* type redefinition:                     Button Type Precedence.
                                                              (line  24)
* uncompressing archives:                Obtaining.           (line  56)
* unpacking archives:                    Obtaining.           (line  56)
* unsubscribing from a mail list:        Mail Lists.          (line  18)
* URL <1>:                               Smart Keyboard Keys. (line 406)
* URL <2>:                               Action Types.        (line 137)
* URL:                                   Implicit Buttons.    (line 132)
* USENET <1>:                            Buttons in News.     (line   6)
* USENET:                                Buttons in Mail.     (line  12)
* variables:                             Hook Variables.      (line   6)
* version description:                   Suggestion or Bug Reporting.
                                                              (line   9)
* vertical drag:                         Smart Mouse Keys.    (line  61)
* view <1>:                              Glossary.            (line 312)
* view:                                  Viewing.             (line   6)
* view spec <1>:                         Glossary.            (line 317)
* view spec:                             View Specs.          (line   6)
* view spec klink:                       Links.               (line  49)
* view spec, all lines and levels:       View Specs.          (line  30)
* view spec, blank lines:                View Specs.          (line  33)
* view spec, changing:                   View Specs.          (line  24)
* view spec, characters:                 View Specs.          (line  30)
* view spec, ellipses:                   View Specs.          (line  43)
* view spec, example:                    View Specs.          (line  73)
* view spec, label type:                 View Specs.          (line  49)
* view spec, lines per cell:             View Specs.          (line  39)
* view spec, setting:                    View Specs.          (line  24)
* view spec, show levels:                View Specs.          (line  46)
* VM:                                    Buttons in Mail.     (line  12)
* W3:                                    Smart Keyboard Keys. (line 406)
* wconfig commands:                      Window Configurations.
                                                              (line  29)
* window configuration commands:         Window Configurations.
                                                              (line  29)
* window configurations:                 Window Configurations.
                                                              (line   6)
* window system:                         External Viewers.    (line   6)
* windows:                               Glossary.            (line  47)
* world-wide web:                        Smart Keyboard Keys. (line 406)
* World-wide Web <1>:                    Action Types.        (line 137)
* World-wide Web:                        Implicit Buttons.    (line 132)
* wrolo:                                 Rolodex.             (line   6)
* Wrolo commands:                        Rolo Menu.           (line  10)
* wrolo matches:                         Smart Keyboard Keys. (line 418)
* wrolo menu:                            Rolo Keys.           (line   9)
* WWW <1>:                               Action Types.        (line 137)
* WWW:                                   Implicit Buttons.    (line 132)
* xdb:                                   Implicit Buttons.    (line  50)
* XEmacs <1>:                            Menus.               (line   6)
* XEmacs:                                Top.                 (line  37)
* XEmacs support:                        Button Colors.       (line   6)
* yank, reformatting:                    Hook Variables.      (line  65)
* zcat:                                  Obtaining.           (line  56)
* |:                                     View Specs.          (line   6)



Tag Table:
Node: Top983
Node: Introduction8427
Node: Hyperbole Overview8805
Node: Mail Lists13395
Node: Manual Overview16076
Node: Installation18874
Node: Obtaining19506
Node: Building21112
Node: Installing22735
Node: Configuring26045
Node: Internal Viewers26509
Node: External Viewers27498
Node: Link Variable Substitution28590
Node: Button Colors29773
Node: Buttons31033
Node: Explicit Buttons31534
Node: Global Buttons33370
Node: Implicit Buttons34293
Node: Action Types39990
Node: Button Type Precedence45436
Node: Button Files46990
Node: Utilizing Explicit Buttons49071
Node: Creation49562
Node: By Dragging49842
Node: By Menu51757
Node: Renaming53867
Node: Deletion55289
Node: Modification55997
Node: Location56583
Node: Buttons in Mail57972
Node: Buttons in News61616
Node: Smart Keys63347
Node: Menus71905
Node: Entering Arguments75033
Node: Outliner76559
Node: Menu Commands78593
Node: Creating Outlines79988
Node: Autonumbering81098
Node: Idstamps84124
Node: Editing85040
Node: Adding and Killing86218
Node: Relocating and Copying87172
Node: Moving Around90176
Node: Filling91276
Node: Transposing92358
Node: Splitting and Appending93182
Node: Inserting and Importing94216
Node: Viewing97121
Node: Hiding and Showing97403
Node: View Specs99037
Node: Links101690
Node: Cell Attributes104306
Node: Outliner History105965
Node: Rolodex106857
Node: Rolo Concepts107505
Node: Rolo Menu109923
Node: Rolo Keys112249
Node: Rolo Settings114586
Node: Window Configurations116810
Node: Developing with Hyperbole120679
Node: Hook Variables121154
Node: Creating Types124488
Node: Action Type Creation125400
Node: Implicit Button Types128910
Node: Explicit Button Technicalities132042
Node: Button Label Normalization132373
Node: Operational and Storage Formats133841
Node: Programmatic Button Creation135049
Node: Encapsulating Systems136018
Node: Embedding Hyperbole137120
Node: Glossary138746
Node: Smart Key Reference151296
Node: Smart Mouse Keys152217
Node: Smart Keyboard Keys155608
Node: Outliner Keys174569
Node: Suggestion or Bug Reporting192856
Node: Questions and Answers195020
Node: Future Work198326
Node: References202741
Node: Key Binding Index207234
Node: Code and File Index216605
Node: Concept Index243919

End Tag Table
